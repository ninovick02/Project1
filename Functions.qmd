---
title: "Functions"
format: html
editor: visual
---

*You can edit this however you like. I just put the instructions on the page so I wouldn't have to toggle* No worries I figure we can focus on the code and clean up the explanation toward the end. I am still going to try and explain as I go so you/I don't get lost but it may not be the most poetic writing.

# Creating the Functions used on this Project

## Querying the Census API and returning a table

### Quoted string

Creating a function to call on specified variables from the Census API. Method: passing along variables to a paste statement based on the following specifications

-   Contains a year between 2010-2022

-   Return at least 2 numeric variables: PUMS person weight (PWGTP) and at least 1 of the following

    -   Age (AGEP), Gas Cost (GASP), Gross rent as a percentage of household income (GRPIP), Time of arrival at work (JWAP), Time of departure from work (JWDP), Travel time to work (JWMNP)

-   Return at least 1 categorical variable

    -   (FER), (HHL), (HISPEED), (JWTRNS), (SCH), (SCHL), (SEX)

-   Optional argument to subset the data based on geography (All, Regions, Divisions, or States)

Setting up the needed packages for this project. Note please make sure you install these packages in your console before calling them with the library statement!

```{r}
# Libraries we need 
# For building function
library("tidyverse")
# To query API
library("httr")
library("jsonlite")
```

The first step in our homework is to try and query an API. I chose a random URL to test before we get into our function writing.

```{r}
# "Start by getting the usual process to work with a given URL"
# I am setting up trial url
test_URL <- "https://api.census.gov/data/2012/acs/acs1/pumspr?get=SEX,PWGTP,MAR&SCHL=24"
raw_info <-GET(test_URL)
parsed <- fromJSON(rawToChar(raw_info$content))
# The first row is column names so we have to adjust 
test_info <- as_tibble(parsed[-1,])
colnames(test_info) <- parsed[1,] 
test_info
```

If you click on the link it looks like our code worked great! Let's work on the second step, writing a helper function to iterate this process.

```{r}
# "Write a helper function to take what is returned by GET() and turn it into a nice tibble"
# This assumes valid URL is used and has the same structure as our above example if our other function is thorough enough
# then this should not be an issue. 
URL_funct <-function(Census_URL){ 
  raw_info <-GET(Census_URL)
  parsed <-fromJSON(rawToChar(raw_info$content))
  Census_info <- as_tibble(parsed[-1,])
  colnames(Census_info) <- parsed[1,] 
  return(Census_info)
  
  
  # Turn categorical variables into factors
  
  # FER
  if ("FER" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
    mutate(FER = factor(as.numeric(FER), levels = c(0:2), labels = c("N/A (less than 15 years/greater than 50 years/ male)", "No", "Yes")))
  }  
  
  # HHL
    if ("HHL" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
    mutate(HHL = factor(as.numeric(HHL), levels = c(0:5), labels = c("N/A (GQ/Vacant)", "Spanish","Other Indo-European languages", "English Only","Asian and Pacific Island languages", "Other Language")))
    }  
  
   # HISPEED 
  if ("HISPEED" %in% colnames(Census_info)) {
     Census_info <- Census_info |>
     mutate(HISPEED = factor(as.numeric(HISPEED), levels = c(0:2), labels = c("N/A (GQ/vacant/no paid access to internet)", "Yes", "No")))
  }
  

  # JWTRNS
  if ("JWTRNS" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
    mutate(JWTRNS = factor(as.numeric(JWTRNS), levels = (0:12),
                          labels = c("N/A (not a worker-not in the labor force, including persons under 16 years; unemployed; employed, with a job but not at work; Armed Forces, with a job but not at work)","Car, truck, or van","Bus","Subway or elevated rail","Long-distance train or commuter rail","Light rail, streetcar, or trolley","Ferryboat","Taxicab","Motorcycle","Bicycle","Walked","Worked from home","Other method")))
  }
  # SCH
  if ("SCH" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
    mutate(SCH = factor(as.numeric(SCH), levels = 0:2,labels = c("N/A (less than 3 years old)","No, has not attended in the last 3 months","Yes, public school or public college","Yes, private school or college or home school"))) 
  }
  
  # SCHL (education)
  if ("SCHL" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
    mutate(SCHL = factor(as.numeric(SCHL),levels = (0:24),labels = c("N/A (less than 3 years old)", "No schooling completed","Nursery school, preschool","Kindergarten","Grade 1","Grade 2","Grade 3","Grade 4","Grade 5","Grade 6","Grade 7","Grade 8","Grade 9","Grade 10","Grade 11","12th grade - no diploma","Regular high school diploma","GED or alternative credential","Some college, but less than 1 year","1 or more years of college credit, no degree","Associate's degree","Bachelor's degree","Master's degree","Professional degree beyond a bachelor's degree","Doctorate degree")))
  }
  
   # SEX
  if ("SEX" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
      mutate(SEX = factor(as.numeric(SEX), levels = c(1:2),labels = c("Male", "Female")))
  }
 
}
```

```{r}
query_api <- function(year=2022, vars = c("PWGTP"=NA, "AGEP"=NA, "SEX"=NA), geo_level = "all" , geo_code = NULL){
  # year = year of census to call, default is 2022
  # vars = vector of numerical and categorical indexes associated with their names default is PWGTP, AGEP, and SEX
  # geo_level = geographic level Region, Division or State, default is all of the US 
  # geo_code = geographic code default is null as this is optional
  
  
  # Making variable choices align with instructions
  
  #Empty for now
  geo_str<-""
  
  # User input to upper/lower case
  # i made geo lower case because thats how it is in url
  names(vars) <- toupper(names(vars))
  geo_level <- tolower(geo_level)
  
  # All variable options
  n_valid_vars <- c("PWGTP", "AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP")
  c_valid_vars <- c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX")
  valid_level <- c("region", "division", "state", "all")
  
  # Creating tibble of valid n and c var limits based on variable information site
  var_limits <- data.frame(names = c(n_valid_vars[-which(names(vars) == "PWGTP")], c_valid_vars), 
                          lower_bound = c(0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1), 
                          upper_bound = c(99, 9999, 101, 285, 150, 200, 2, 5, 2, 12, 3, 24, 2))
  
  # Keep only those that appear in both
  n_var_names <- intersect(names(vars), n_valid_vars)
  c_var_names <- intersect(names(vars), c_valid_vars)
  geo_name <- intersect(geo_level, valid_level)
  
  # This checks that year is numeric, not multiple years and between '10 and '22
  if (!is.numeric(year) | length(year) != 1){
    stop("Warning: Year must be a single numeric value")
  } else if(year > 2022 | year < 2010){
    stop("Warning: Year must be between 2010-2022")
  }
  
  # Vars asked for in the set/at least 1 categorical
  if (length(n_var_names) == 0 | length(c_var_names) == 0){
    stop("Warning: One or more variables are invalid or not enough variables as argument")
  } 
  
  # Giving note if one of the variable calls is invalid and subsetting to valid variables
  if ((length(n_var_names) + length(c_var_names)) < length(names(vars))){
      print("Note: One or more variables are invalid, returning only valid variables")
    vars <- vars[c(n_var_names, c_var_names)]
  }

  # PWEGTP always included and at least one other numeric var
  if (length(n_var_names) < 2 | !("PWGTP" %in% n_var_names)){
    stop("Warning: PWGTP and at least 1 other valid numerical vector must be an argument")
  }
  
  # Assigning valid geo code based on selected region
  if (geo_name == "region"){
    valid_code <- c(1:4)
  } else if (geo_name == "division"){
      valid_code <- c(1:9)
  } else if (geo_name == "state"){
      valid_code <- c(1:56)[-c(3, 7, 14, 43, 52)] 
  } else{
    geo_name <- c("REGION", "DIVISION", "ST") # can they specify all three or does he want us to use 'all' as the catch all?
    geo_code = "*"
  }
  
  if (!(geo_code == "*" || geo_code == round(geo_code))){
    stop('Warning: geo_code must be an integer or "*"') # isnt this covered in other if/else
  }
  
  # Assigning valid indexes for variables
  #Cannot be indexed: PWGTP
  for (i in 1:length(vars[-which(names(vars) == "PWGTP")])){
    if (!is.na(vars[i])){
      
      # Making sure given subset is an integer
      if (vars[i] != round(vars[item])){
        stop("Given subset must be an integer")
      }
      
      # Checking if given subset is within the bounds of the subset
      if (var_limits$lower_bound[which(var_limits$names == names(vars[i]))] > vars[i] | var_limits$upper_bound[which(var_limits$names == names(vars[i]))] < vars[i]){
        print(paste("Invalid Variable Subsetting. Returning all values of variable", names(vars[i])))
        vars[i] = NA
      } else if ((names(vars[i]) %in% n_var_names)){
          print("Note: Numerical variable subsetted. While within the given range, Specific number may not be in the data")
      }
      
    }
  }
  
  # Fill geo_str 
 
  if(length(geo_name) > 1){ # i am confused about the first if 
    geo_str <- paste0(geo_name, collapse=,)
  } else if (geo_level %in% valid_level && ((geo_code %in% valid_code) | geo_code == "*")){
      geo_str<-paste0("&for=", geo_level, ":" ,geo_code)
  } else if (!(geo_level %in% valid_geo & geo_level != "all")){
      stop("Warning: Provided geography level is not valid")
  } else if (!(geo_code %in% valid_code)){
      stop("Warning: Provided geography code is not valid for your geography level")
  }

  

 if(!all(is.na(vars))){
   if(length(geo_name) > 1){
     api_url <- paste0("https://api.census.gov/data/", year, "/acs/acs1/pums?get=", 
                      paste(names(vars)[is.na(vars)], collapse=","), geo_str, "&",
                      paste0(names(vars)[!is.na(vars)], "=", vars[!is.na(vars)], collapse="&"))
   } else{
     api_url <- paste0("https://api.census.gov/data/", year, "/acs/acs1/pums?get=", 
                      paste(names(vars)[is.na(vars)], collapse=","), "&",
                      paste0(names(vars)[!is.na(vars)], "=", vars[!is.na(vars)], collapse="&"), geo_str)
   }
 } else{
    api_url <- paste0("https://api.census.gov/data/", year, "/acs/acs1/pums?get=", 
                      paste(names(vars)[is.na(vars)], collapse=","), geo_str)
 }
    
  return(URL_funct(api_url))

  
}
```
