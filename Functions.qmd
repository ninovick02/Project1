---
title: "Functions"
format: html
editor: visual
---

*You can edit this however you like. I just put the instructions on the page so I wouldn't have to toggle*

# Creating the Functions used on this Project

## Querying the Census API and returning a table

### Quoted string

Creating a function to call on specified variables from the Census API. Method: passing along variables to a paste statement based on the following specifications

-   Contains a year between 2010-2022

-   Return at lease 2 numeric variables: PUMS person weight (PWGTP) and at least 1 of the following

    -   Age (AGEP), Gas Cost (GASP), Gross rent as a percentage of household income (GRPIP), Time of arrival at work (JWAP), Time of departure from work (JWDP), Travel time to work (JWMNP)

-   Return at least 1 categorical variable

    -   (FER), (HHL), (HISPEED), (JWTRNS), (SCH), (SCHL), (SEX)

-   Optional argument to subset the data based on geography (All, Regions, Divisions, or States)

```{r}
# Helper function to turn GET() to a tibble
```

```{r}
query_api <- function(year, vars = c("PWGTP"=NA, "AGEP"=NA, "SEX"=NA), geo = c("ALL"=NA)){
  # year = year of census to call
  # vars = vector of numerical and categorical indexes associated with their names
    # This is a little annoying to type out, so we can change it later
  # geo = vector of geographic sub division similar to vec. all = Regions, Divisions, and States
  
  
  # Making variable choices align with instructions
  names(vars) <- toupper(names(vars))
  names(geo) <- toupper(names(geo))
  
  n_valid_vars <- c("PWGTP", "AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP")
  c_valid_vars <- c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX")
  
  n_var_names <- intersect(names(vars), n_valid_vars)
  c_var_names <- intersect(names(vars), c_valid_vars)
  
  if (!is.numeric(year) | length(year) != 1){
    stop("Warning: Year must be a single numeric value")
  } else if(year > 2022 | year < 2010){
    stop("Warning: Year must be between 2010-2022")
  }
  
  if (length(n_var_names) == 0 | length(c_var_names) == 0){
    stop("Warning: One or more variables are invalid or not enough variables as argument")
  } 

  if (length(n_var_names) < 2 | !("PWGTP" %in% n_var_names)){
    stop("Warning: PWGTP and at least 1 other valid numerical vector must be an argument")
  }
  
  if(!(names(geo) %in% c("ALL", "REGIONS", "DIVISIONS", "STATES"))){
    stop("Warning: Invalid geography level")
  }
  
  if ("ALL" %in% geo){
    names(geo) <- c("REGIONS", "DIVISIONS", "STATES")
  }
  # Need to go through api site and find suitable values for variable indexes and filter out bad values
    # I'm thinking that if they put in a bad value, we print a warning, but give them the variable without an index
  
  
  # Can't figure out how to do all the geography variables in one go. Will need to call multiple tables from the api and merge left with the "main variable tibble"
  main_var_url <- ifelse(!all(is.na(vars)), 
                    paste0("https://api.census.gov/data/", as.character(year), "/acs/acs1/pums?get=", 
                      paste(names(vars)[is.na(vars)], collapse=","), "&",
                      paste0(names(vars)[!is.na(vars)], "=", vars[!is.na(vars)], collapse="&")), 
                    paste0("https://api.census.gov/data/", as.character(year), "/acs/acs1/pums?get=", 
                      paste(names(vars)[is.na(vars)], collapse=","))
    )
  # Now to make the geography level urls. in the form of &for=geolevel:index
  
  # Use first function to make into tibbles
  main_var_tbl <- funct(main_var_url)
  geo_tbl <- funct(geo_url)
  
  # Merge left main_var, geo
  
}
```
