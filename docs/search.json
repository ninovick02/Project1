[
  {
    "objectID": "Proj1Code.html#loading-libraries",
    "href": "Proj1Code.html#loading-libraries",
    "title": "Project 1",
    "section": "Loading libraries",
    "text": "Loading libraries\nSetting up the needed packages for this project. Note please make sure you install these packages in your console before calling them with the library statement!\n\n# Libraries we need \n# For various parts of building our functions\nlibrary(\"tidyverse\")\n\nWarning: package 'tidyverse' was built under R version 4.3.3\n\n\nWarning: package 'ggplot2' was built under R version 4.3.1\n\n\nWarning: package 'readr' was built under R version 4.3.1\n\n\nWarning: package 'forcats' was built under R version 4.3.1\n\n\nWarning: package 'lubridate' was built under R version 4.3.3\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# To query API\nlibrary(\"httr\")\nlibrary(\"jsonlite\")\n\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\n# time mid pt function\nlibrary(\"hms\")\n\nWarning: package 'hms' was built under R version 4.3.1\n\n\n\nAttaching package: 'hms'\n\nThe following object is masked from 'package:lubridate':\n\n    hms"
  },
  {
    "objectID": "Proj1Code.html#creating-table-from-a-given-api-url",
    "href": "Proj1Code.html#creating-table-from-a-given-api-url",
    "title": "Project 1",
    "section": "Creating Table from a given API URL",
    "text": "Creating Table from a given API URL\nThe first step in our homework is to try and query an API. I chose a random URL to test before we get into our function writing.\n\n# I am setting up trial url\ntest_URL &lt;- \"https://api.census.gov/data/2012/acs/acs1/pumspr?get=SEX,PWGTP,MAR&SCHL=24\"\nraw_info &lt;-GET(test_URL)\nparsed &lt;- fromJSON(rawToChar(raw_info$content))\n# The first row is column names so we have to adjust \ntest_info &lt;- as_tibble(parsed[-1,])\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\ncolnames(test_info) &lt;- parsed[1,] \ntest_info\n\n# A tibble: 189 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 1     38    1     24   \n 2 2     120   1     24   \n 3 1     43    1     24   \n 4 2     25    2     24   \n 5 1     80    3     24   \n 6 1     83    1     24   \n 7 2     109   1     24   \n 8 1     74    1     24   \n 9 1     63    3     24   \n10 2     63    1     24   \n# ℹ 179 more rows"
  },
  {
    "objectID": "Proj1Code.html#creating-generalized-function-to-turn-api-url-to-a-table",
    "href": "Proj1Code.html#creating-generalized-function-to-turn-api-url-to-a-table",
    "title": "Project 1",
    "section": "Creating Generalized Function to turn API URL to a Table",
    "text": "Creating Generalized Function to turn API URL to a Table\nIf you click on the link it looks like our code worked great!\n\nHelper Function to Determine Time Variable Mid Points\nWe will now define a function to help us determine mid point for time intervals of the form “9:15 a.m. to 9:19 a.m.” which happens in the variables JWAP and JWDP. Our function should return 9:17 AM.\n\n# function to do mid point of time\n\nmid_time &lt;- function(time) {\n  if (time == \"NA\" || time == \"0\") {\n    return(NA)\n  }\n  \n  # Split interval into start and end times\n  parts &lt;- str_split(time, \" to \", simplify = TRUE)\n  start &lt;- parts[1]\n  end   &lt;- parts[2]\n  \n  # ran into issue because hms uses AM PM with no dots, this cleans it\n  start &lt;- str_replace_all(start, c(\"a.m.\" = \"AM\", \"p.m.\" = \"PM\"))\n  end   &lt;- str_replace_all(end,   c(\"a.m.\" = \"AM\", \"p.m.\" = \"PM\"))\n  \n  # using hms (time format) because of forum Dr. Post mentioned it\n  start_hms &lt;- as_hms(strptime(start, format = \"%I:%M %p\"))\n  end_hms   &lt;- as_hms(strptime(end,   format = \"%I:%M %p\"))\n\n  # Compute midpoint via average seconds between start and end\n  # note we were told we can round to get it to the minute only\n  mid_secs &lt;- (as.numeric(start_hms) + as.numeric(end_hms)) / 2\n  mid_secs &lt;- round(mid_secs / 60)*60\n  \n  # back to time format\n  mid_hms  &lt;- as_hms(mid_secs)\n  \n  # back to character, display only hours mins and am/pm\n  # Dr. Post said this its okay to be character\n  out &lt;- format(strptime(as.character(mid_hms), \"%H:%M:%S\"), \"%I:%M %p\")\n  \n  return(out)\n}\n\nWere going to test that our function for mid point in time works with the example we mentioned above!\n\nmid_time(\"9:15 a.m. to 9:19 a.m.\")\n\n[1] \"09:17 AM\"\n\n\nGreat, now lets work on the second step, writing a helper function to iterate this process.\n\n\nGeneralized Helper function\nHere we have to make sure categorical variables that coded with strings of numbers get converted to the correct information via the mutate and factor. We must make sure numeric variables are numeric, and finally we have to make sure our time variables return the middle of the time period.\n\n# This assumes valid URL is used and has the same structure as our above example if our other function is thorough enough then this should not be an issue. \nURL_funct &lt;-function(Census_URL){ \n  raw_info &lt;-GET(Census_URL)\n  parsed &lt;-fromJSON(rawToChar(raw_info$content))\n  Census_info &lt;- as_tibble(parsed[-1,])\n  colnames(Census_info) &lt;- parsed[1,] \n  \n  \n  # Turn categorical variables into factors with the appropriate levels using if logic to see if the column is in our tibble\n  \n  # FER\n  if (\"FER\" %in% colnames(Census_info)) {\n    Census_info &lt;- Census_info |&gt;\n     mutate(FER = factor(as.numeric(FER), levels = c(0:2), labels = c(\"N/A (less than 15 years/greater than 50 years/ male)\", \"No\", \"Yes\")))\n  }  \n  \n  # HHL\n    if (\"HHL\" %in% colnames(Census_info)) {\n    Census_info &lt;- Census_info |&gt;\n     mutate(HHL = factor(as.numeric(HHL), levels = c(0:5), labels = c(\"N/A (GQ/Vacant)\", \"Spanish\",\"Other Indo-European languages\", \"English Only\",\"Asian and Pacific Island languages\", \"Other Language\")))\n    }  \n  \n   # HISPEED \n  if (\"HISPEED\" %in% colnames(Census_info)) {\n     Census_info &lt;- Census_info |&gt;\n       mutate(HISPEED = factor(as.numeric(HISPEED), levels = c(0:2), labels = c(\"N/A (GQ/vacant/no paid access to internet)\", \"Yes\", \"No\")))\n  }\n  \n\n  # JWTRNS\n  if (\"JWTRNS\" %in% colnames(Census_info)) {\n    Census_info &lt;- Census_info |&gt;\n     mutate(JWTRNS = factor(as.numeric(JWTRNS), levels = (0:12),\n                          labels = c(\"N/A (not a worker-not in the labor force, including persons under 16 years; unemployed; employed, with a job but not at work; Armed Forces, with a job but not at work)\",\"Car, truck, or van\",\"Bus\",\"Subway or elevated rail\",\"Long-distance train or commuter rail\",\"Light rail, streetcar, or trolley\",\"Ferryboat\",\"Taxicab\",\"Motorcycle\",\"Bicycle\",\"Walked\",\"Worked from home\",\"Other method\")))\n  }\n  # SCH\n  if (\"SCH\" %in% colnames(Census_info)) {\n    Census_info &lt;- Census_info |&gt;\n      mutate(SCH = factor(as.numeric(SCH), levels = 0:2,labels = c(\"N/A (less than 3 years old)\",\"No, has not attended in the last 3 months\",\"Yes, public school or public college\",\"Yes, private school or college or home school\"))) \n  }\n  \n  # SCHL (education)\n  if (\"SCHL\" %in% colnames(Census_info)) {\n    Census_info &lt;- Census_info |&gt;\n      mutate(SCHL = factor(as.numeric(SCHL),levels = (0:24),labels = c(\"N/A (less than 3 years old)\", \"No schooling completed\",\"Nursery school, preschool\",\"Kindergarten\",\"Grade 1\",\"Grade 2\",\"Grade 3\",\"Grade 4\",\"Grade 5\",\"Grade 6\",\"Grade 7\",\"Grade 8\",\"Grade 9\",\"Grade 10\",\"Grade 11\",\"12th grade - no diploma\",\"Regular high school diploma\",\"GED or alternative credential\",\"Some college, but less than 1 year\",\"1 or more years of college credit, no degree\",\"Associate's degree\",\"Bachelor's degree\",\"Master's degree\",\"Professional degree beyond a bachelor's degree\",\"Doctorate degree\")))\n  }\n  \n  # SEX\n  if (\"SEX\" %in% colnames(Census_info)) {\n    Census_info &lt;- Census_info |&gt;\n      mutate(SEX = factor(as.numeric(SEX), levels = c(1:2),labels = c(\"Male\", \"Female\")))\n  }\n  \n  # Next convert numeric variables with similar if logic to check if they are in tibble we can loop through this\n  \n  num_vars &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\")\n\n  for (i in num_vars) {\n    if (i %in% colnames(Census_info)) {\n    Census_info[[i]] &lt;- as.numeric(Census_info[[i]])\n    }\n  }\n  \n  \n  # taken from Census API site with : swapped for =\n  # Creating list of all possible values of JWAP\n  # We will use the midtime function on this and the JWDP list to create all possible factor levels for these variables\n  times_JWAP &lt;-c(\n      \"258\"= \"9:40 p.m. to 9:44 p.m.\",\n      \"260\"= \"9:50 p.m. to 9:54 p.m.\",\n      \"261\"= \"9:55 p.m. to 9:59 p.m.\",\n      \"274\"= \"11:00 p.m. to 11:04 p.m.\",\n      \"048\"= \"4:10 a.m. to 4:14 a.m.\",\n      \"058\"= \"5:00 a.m. to 5:04 a.m.\",\n      \"076\"= \"6:30 a.m. to 6:34 a.m.\",\n      \"091\"= \"7:45 a.m. to 7:49 a.m.\",\n      \"094\"= \"8:00 a.m. to 8:04 a.m.\",\n      \"122\"= \"10:20 a.m. to 10:24 a.m.\",\n      \"142\"= \"12:00 p.m. to 12:04 p.m.\",\n      \"146\"= \"12:20 p.m. to 12:24 p.m.\",\n      \"163\"= \"1:45 p.m. to 1:49 p.m.\",\n      \"165\"= \"1:55 p.m. to 1:59 p.m.\",\n      \"171\"= \"2:25 p.m. to 2:29 p.m.\",\n      \"184\"= \"3:30 p.m. to 3:34 p.m.\",\n      \"189\"= \"3:55 p.m. to 3:59 p.m.\",\n      \"192\"= \"4:10 p.m. to 4:14 p.m.\",\n      \"198\"= \"4:40 p.m. to 4:44 p.m.\",\n      \"210\"= \"5:40 p.m. to 5:44 p.m.\",\n      \"218\"= \"6:20 p.m. to 6:24 p.m.\",\n      \"220\"= \"6:30 p.m. to 6:34 p.m.\",\n      \"221\"= \"6:35 p.m. to 6:39 p.m.\",\n      \"222\"= \"6:40 p.m. to 6:44 p.m.\",\n      \"224\"= \"6:50 p.m. to 6:54 p.m.\",\n      \"227\"= \"7:05 p.m. to 7:09 p.m.\",\n      \"228\"= \"7:10 p.m. to 7:14 p.m.\",\n      \"251\"= \"9:05 p.m. to 9:09 p.m.\",\n      \"256\"= \"9:30 p.m. to 9:34 p.m.\",\n      \"259\"= \"9:45 p.m. to 9:49 p.m.\",\n      \"262\"= \"10:00 p.m. to 10:04 p.m.\",\n      \"270\"= \"10:40 p.m. to 10:44 p.m.\",\n      \"271\"= \"10:45 p.m. to 10:49 p.m.\",\n      \"276\"= \"11:10 p.m. to 11:14 p.m.\",\n      \"284\"= \"11:50 p.m. to 11:54 p.m.\",\n      \"006\"= \"12:25 a.m. to 12:29 a.m.\",\n      \"008\"= \"12:40 a.m. to 12:44 a.m.\",\n      \"009\"= \"12:45 a.m. to 12:49 a.m.\",\n      \"011\"= \"1:00 a.m. to 1:04 a.m.\",\n      \"017\"= \"1:30 a.m. to 1:34 a.m.\",\n      \"020\"= \"1:45 a.m. to 1:49 a.m.\",\n      \"031\"= \"2:45 a.m. to 2:49 a.m.\",\n      \"039\"= \"3:25 a.m. to 3:29 a.m.\",\n      \"053\"= \"4:35 a.m. to 4:39 a.m.\",\n      \"065\"= \"5:35 a.m. to 5:39 a.m.\",\n      \"075\"= \"6:25 a.m. to 6:29 a.m.\",\n      \"085\"= \"7:15 a.m. to 7:19 a.m.\",\n      \"090\"= \"7:40 a.m. to 7:44 a.m.\",\n      \"101\"= \"8:35 a.m. to 8:39 a.m.\",\n      \"107\"= \"9:05 a.m. to 9:09 a.m.\",\n      \"121\"= \"10:15 a.m. to 10:19 a.m.\",\n      \"124\"= \"10:30 a.m. to 10:34 a.m.\",\n      \"137\"= \"11:35 a.m. to 11:39 a.m.\",\n      \"156\"= \"1:10 p.m. to 1:14 p.m.\",\n      \"164\"= \"1:50 p.m. to 1:54 p.m.\",\n      \"173\"= \"2:35 p.m. to 2:39 p.m.\",\n      \"197\"= \"4:35 p.m. to 4:39 p.m.\",\n      \"202\"= \"5:00 p.m. to 5:04 p.m.\",\n      \"234\"= \"7:40 p.m. to 7:44 p.m.\",\n      \"235\"= \"7:45 p.m. to 7:49 p.m.\",\n      \"246\"= \"8:40 p.m. to 8:44 p.m.\",\n      \"249\"= \"8:55 p.m. to 8:59 p.m.\",\n      \"257\"= \"9:35 p.m. to 9:39 p.m.\",\n      \"273\"= \"10:55 p.m. to 10:59 p.m.\",\n      \"277\"= \"11:15 p.m. to 11:19 p.m.\",\n      \"002\"= \"12:05 a.m. to 12:09 a.m.\",\n      \"004\"= \"12:15 a.m. to 12:19 a.m.\",\n      \"015\"= \"1:20 a.m. to 1:24 a.m.\",\n      \"034\"= \"3:00 a.m. to 3:04 a.m.\",\n      \"035\"= \"3:05 a.m. to 3:09 a.m.\",\n      \"042\"= \"3:40 a.m. to 3:44 a.m.\",\n      \"044\"= \"3:50 a.m. to 3:54 a.m.\",\n      \"050\"= \"4:20 a.m. to 4:24 a.m.\",\n      \"052\"= \"4:30 a.m. to 4:34 a.m.\",\n      \"055\"= \"4:45 a.m. to 4:49 a.m.\",\n      \"069\"= \"5:55 a.m. to 5:59 a.m.\",\n      \"071\"= \"6:05 a.m. to 6:09 a.m.\",\n      \"077\"= \"6:35 a.m. to 6:39 a.m.\",\n      \"079\"= \"6:45 a.m. to 6:49 a.m.\",\n      \"082\"= \"7:00 a.m. to 7:04 a.m.\",\n      \"089\"= \"7:35 a.m. to 7:39 a.m.\",\n      \"092\"= \"7:50 a.m. to 7:54 a.m.\",\n      \"093\"= \"7:55 a.m. to 7:59 a.m.\",\n      \"097\"= \"8:15 a.m. to 8:19 a.m.\",\n      \"117\"= \"9:55 a.m. to 9:59 a.m.\",\n      \"118\"= \"10:00 a.m. to 10:04 a.m.\",\n      \"129\"= \"10:55 a.m. to 10:59 a.m.\",\n      \"132\"= \"11:10 a.m. to 11:14 a.m.\",\n      \"138\"= \"11:40 a.m. to 11:44 a.m.\",\n      \"144\"= \"12:10 p.m. to 12:14 p.m.\",\n      \"148\"= \"12:30 p.m. to 12:34 p.m.\",\n      \"150\"= \"12:40 p.m. to 12:44 p.m.\",\n      \"152\"= \"12:50 p.m. to 12:54 p.m.\",\n      \"166\"= \"2:00 p.m. to 2:04 p.m.\",\n      \"181\"= \"3:15 p.m. to 3:19 p.m.\",\n      \"183\"= \"3:25 p.m. to 3:29 p.m.\",\n      \"205\"= \"5:15 p.m. to 5:19 p.m.\",\n      \"219\"= \"6:25 p.m. to 6:29 p.m.\",\n      \"230\"= \"7:20 p.m. to 7:24 p.m.\",\n      \"233\"= \"7:35 p.m. to 7:39 p.m.\",\n      \"239\"= \"8:05 p.m. to 8:09 p.m.\",\n      \"244\"= \"8:30 p.m. to 8:34 p.m.\",\n      \"254\"= \"9:20 p.m. to 9:24 p.m.\",\n      \"265\"= \"10:15 p.m. to 10:19 p.m.\",\n      \"272\"= \"10:50 p.m. to 10:54 p.m.\",\n      \"013\"= \"1:10 a.m. to 1:14 a.m.\",\n      \"014\"= \"1:15 a.m. to 1:19 a.m.\",\n      \"019\"= \"1:40 a.m. to 1:44 a.m.\",\n      \"022\"= \"2:00 a.m. to 2:04 a.m.\",\n      \"033\"= \"2:55 a.m. to 2:59 a.m.\",\n      \"037\"= \"3:15 a.m. to 3:19 a.m.\",\n      \"041\"= \"3:35 a.m. to 3:39 a.m.\",\n      \"059\"= \"5:05 a.m. to 5:09 a.m.\",\n      \"067\"= \"5:45 a.m. to 5:49 a.m.\",\n      \"068\"= \"5:50 a.m. to 5:54 a.m.\",\n      \"074\"= \"6:20 a.m. to 6:24 a.m.\",\n      \"080\"= \"6:50 a.m. to 6:54 a.m.\",\n      \"084\"= \"7:10 a.m. to 7:14 a.m.\",\n      \"088\"= \"7:30 a.m. to 7:34 a.m.\",\n      \"095\"= \"8:05 a.m. to 8:09 a.m.\",\n      \"100\"= \"8:30 a.m. to 8:34 a.m.\",\n      \"125\"= \"10:35 a.m. to 10:39 a.m.\",\n      \"140\"= \"11:50 a.m. to 11:54 a.m.\",\n      \"172\"= \"2:30 p.m. to 2:34 p.m.\",\n      \"178\"= \"3:00 p.m. to 3:04 p.m.\",\n      \"182\"= \"3:20 p.m. to 3:24 p.m.\",\n      \"185\"= \"3:35 p.m. to 3:39 p.m.\",\n      \"187\"= \"3:45 p.m. to 3:49 p.m.\",\n      \"199\"= \"4:45 p.m. to 4:49 p.m.\",\n      \"206\"= \"5:20 p.m. to 5:24 p.m.\",\n      \"208\"= \"5:30 p.m. to 5:34 p.m.\",\n      \"209\"= \"5:35 p.m. to 5:39 p.m.\",\n      \"243\"= \"8:25 p.m. to 8:29 p.m.\",\n      \"268\"= \"10:30 p.m. to 10:34 p.m.\",\n      \"269\"= \"10:35 p.m. to 10:39 p.m.\",\n      \"279\"= \"11:25 p.m. to 11:29 p.m.\",\n      \"001\"= \"12:00 a.m. to 12:04 a.m.\",\n      \"005\"= \"12:20 a.m. to 12:24 a.m.\",\n      \"007\"= \"12:30 a.m. to 12:39 a.m.\",\n      \"023\"= \"2:05 a.m. to 2:09 a.m.\",\n      \"025\"= \"2:15 a.m. to 2:19 a.m.\",\n      \"029\"= \"2:35 a.m. to 2:39 a.m.\",\n      \"036\"= \"3:10 a.m. to 3:14 a.m.\",\n      \"043\"= \"3:45 a.m. to 3:49 a.m.\",\n      \"046\"= \"4:00 a.m. to 4:04 a.m.\",\n      \"051\"= \"4:25 a.m. to 4:29 a.m.\",\n      \"056\"= \"4:50 a.m. to 4:54 a.m.\",\n      \"073\"= \"6:15 a.m. to 6:19 a.m.\",\n      \"081\"= \"6:55 a.m. to 6:59 a.m.\",\n      \"098\"= \"8:20 a.m. to 8:24 a.m.\",\n      \"103\"= \"8:45 a.m. to 8:49 a.m.\",\n      \"106\"= \"9:00 a.m. to 9:04 a.m.\",\n      \"114\"= \"9:40 a.m. to 9:44 a.m.\",\n      \"135\"= \"11:25 a.m. to 11:29 a.m.\",\n      \"143\"= \"12:05 p.m. to 12:09 p.m.\",\n      \"149\"= \"12:35 p.m. to 12:39 p.m.\",\n      \"157\"= \"1:15 p.m. to 1:19 p.m.\",\n      \"158\"= \"1:20 p.m. to 1:24 p.m.\",\n      \"160\"= \"1:30 p.m. to 1:34 p.m.\",\n      \"170\"= \"2:20 p.m. to 2:24 p.m.\",\n      \"174\"= \"2:40 p.m. to 2:44 p.m.\",\n      \"179\"= \"3:05 p.m. to 3:09 p.m.\",\n      \"194\"= \"4:20 p.m. to 4:24 p.m.\",\n      \"196\"= \"4:30 p.m. to 4:34 p.m.\",\n      \"211\"= \"5:45 p.m. to 5:49 p.m.\",\n      \"212\"= \"5:50 p.m. to 5:54 p.m.\",\n      \"214\"= \"6:00 p.m. to 6:04 p.m.\",\n      \"241\"= \"8:15 p.m. to 8:19 p.m.\",\n      \"264\"= \"10:10 p.m. to 10:14 p.m.\",\n      \"266\"= \"10:20 p.m. to 10:24 p.m.\",\n      \"016\"= \"1:25 a.m. to 1:29 a.m.\",\n      \"018\"= \"1:35 a.m. to 1:39 a.m.\",\n      \"021\"= \"1:50 a.m. to 1:59 a.m.\",\n      \"028\"= \"2:30 a.m. to 2:34 a.m.\",\n      \"054\"= \"4:40 a.m. to 4:44 a.m.\",\n      \"060\"= \"5:10 a.m. to 5:14 a.m.\",\n      \"064\"= \"5:30 a.m. to 5:34 a.m.\",\n      \"070\"= \"6:00 a.m. to 6:04 a.m.\",\n      \"078\"= \"6:40 a.m. to 6:44 a.m.\",\n      \"087\"= \"7:25 a.m. to 7:29 a.m.\",\n      \"105\"= \"8:55 a.m. to 8:59 a.m.\",\n      \"111\"= \"9:25 a.m. to 9:29 a.m.\",\n      \"119\"= \"10:05 a.m. to 10:09 a.m.\",\n      \"123\"= \"10:25 a.m. to 10:29 a.m.\",\n      \"126\"= \"10:40 a.m. to 10:44 a.m.\",\n      \"134\"= \"11:20 a.m. to 11:24 a.m.\",\n      \"139\"= \"11:45 a.m. to 11:49 a.m.\",\n      \"141\"= \"11:55 a.m. to 11:59 a.m.\",\n      \"151\"= \"12:45 p.m. to 12:49 p.m.\",\n      \"153\"= \"12:55 p.m. to 12:59 p.m.\",\n      \"169\"= \"2:15 p.m. to 2:19 p.m.\",\n      \"180\"= \"3:10 p.m. to 3:14 p.m.\",\n      \"203\"= \"5:05 p.m. to 5:09 p.m.\",\n      \"204\"= \"5:10 p.m. to 5:14 p.m.\",\n      \"207\"= \"5:25 p.m. to 5:29 p.m.\",\n      \"215\"= \"6:05 p.m. to 6:09 p.m.\",\n      \"216\"= \"6:10 p.m. to 6:14 p.m.\",\n      \"217\"= \"6:15 p.m. to 6:19 p.m.\",\n      \"223\"= \"6:45 p.m. to 6:49 p.m.\",\n      \"225\"= \"6:55 p.m. to 6:59 p.m.\",\n      \"247\"= \"8:45 p.m. to 8:49 p.m.\",\n      \"248\"= \"8:50 p.m. to 8:54 p.m.\",\n      \"252\"= \"9:10 p.m. to 9:14 p.m.\",\n      \"253\"= \"9:15 p.m. to 9:19 p.m.\",\n      \"255\"= \"9:25 p.m. to 9:29 p.m.\",\n      \"263\"= \"10:05 p.m. to 10:09 p.m.\",\n      \"267\"= \"10:25 p.m. to 10:29 p.m.\",\n      \"278\"= \"11:20 p.m. to 11:24 p.m.\",\n      \"280\"= \"11:30 p.m. to 11:34 p.m.\",\n      \"281\"= \"11:35 p.m. to 11:39 p.m.\",\n      \"282\"= \"11:40 p.m. to 11:44 p.m.\",\n      \"003\"= \"12:10 a.m. to 12:14 a.m.\",\n      \"010\"= \"12:50 a.m. to 12:59 a.m.\",\n      \"038\"= \"3:20 a.m. to 3:24 a.m.\",\n      \"049\"= \"4:15 a.m. to 4:19 a.m.\",\n      \"057\"= \"4:55 a.m. to 4:59 a.m.\",\n      \"061\"= \"5:15 a.m. to 5:19 a.m.\",\n      \"062\"= \"5:20 a.m. to 5:24 a.m.\",\n      \"072\"= \"6:10 a.m. to 6:14 a.m.\",\n      \"083\"= \"7:05 a.m. to 7:09 a.m.\",\n      \"104\"= \"8:50 a.m. to 8:54 a.m.\",\n      \"108\"= \"9:10 a.m. to 9:14 a.m.\",\n      \"116\"= \"9:50 a.m. to 9:54 a.m.\",\n      \"128\"= \"10:50 a.m. to 10:54 a.m.\",\n      \"133\"= \"11:15 a.m. to 11:19 a.m.\",\n      \"136\"= \"11:30 a.m. to 11:34 a.m.\",\n      \"147\"= \"12:25 p.m. to 12:29 p.m.\",\n      \"154\"= \"1:00 p.m. to 1:04 p.m.\",\n      \"155\"= \"1:05 p.m. to 1:09 p.m.\",\n      \"161\"= \"1:35 p.m. to 1:39 p.m.\",\n      \"162\"= \"1:40 p.m. to 1:44 p.m.\",\n      \"167\"= \"2:05 p.m. to 2:09 p.m.\",\n      \"175\"= \"2:45 p.m. to 2:49 p.m.\",\n      \"177\"= \"2:55 p.m. to 2:59 p.m.\",\n      \"186\"= \"3:40 p.m. to 3:44 p.m.\",\n      \"190\"= \"4:00 p.m. to 4:04 p.m.\",\n      \"191\"= \"4:05 p.m. to 4:09 p.m.\",\n      \"193\"= \"4:15 p.m. to 4:19 p.m.\",\n      \"200\"= \"4:50 p.m. to 4:54 p.m.\",\n      \"201\"= \"4:55 p.m. to 4:59 p.m.\",\n      \"226\"= \"7:00 p.m. to 7:04 p.m.\",\n      \"232\"= \"7:30 p.m. to 7:34 p.m.\",\n      \"236\"= \"7:50 p.m. to 7:54 p.m.\",\n      \"237\"= \"7:55 p.m. to 7:59 p.m.\",\n      \"238\"= \"8:00 p.m. to 8:04 p.m.\",\n      \"240\"= \"8:10 p.m. to 8:14 p.m.\",\n      \"242\"= \"8:20 p.m. to 8:24 p.m.\",\n      \"245\"= \"8:35 p.m. to 8:39 p.m.\",\n      \"250\"= \"9:00 p.m. to 9:04 p.m.\",\n      \"275\"= \"11:05 p.m. to 11:09 p.m.\",\n      \"283\"= \"11:45 p.m. to 11:49 p.m.\",\n      \"285\"= \"11:55 p.m. to 11:59 p.m.\",\n      \"012\"= \"1:05 a.m. to 1:09 a.m.\",\n      \"024\"= \"2:10 a.m. to 2:14 a.m.\",\n      \"026\"= \"2:20 a.m. to 2:24 a.m.\",\n      \"027\"= \"2:25 a.m. to 2:29 a.m.\",\n      \"030\"= \"2:40 a.m. to 2:44 a.m.\",\n      \"032\"= \"2:50 a.m. to 2:54 a.m.\",\n      \"040\"= \"3:30 a.m. to 3:34 a.m.\",\n      \"045\"= \"3:55 a.m. to 3:59 a.m.\",\n      \"047\"= \"4:05 a.m. to 4:09 a.m.\",\n      \"063\"= \"5:25 a.m. to 5:29 a.m.\",\n      \"066\"= \"5:40 a.m. to 5:44 a.m.\",\n      \"086\"= \"7:20 a.m. to 7:24 a.m.\",\n      \"096\"= \"8:10 a.m. to 8:14 a.m.\",\n      \"099\"= \"8:25 a.m. to 8:29 a.m.\",\n      \"102\"= \"8:40 a.m. to 8:44 a.m.\",\n      \"109\"= \"9:15 a.m. to 9:19 a.m.\",\n      \"110\"= \"9:20 a.m. to 9:24 a.m.\",\n      \"112\"= \"9:30 a.m. to 9:34 a.m.\",\n      \"113\"= \"9:35 a.m. to 9:39 a.m.\",\n      \"115\"= \"9:45 a.m. to 9:49 a.m.\",\n      \"120\"= \"10:10 a.m. to 10:14 a.m.\",\n      \"127\"= \"10:45 a.m. to 10:49 a.m.\",\n      \"130\"= \"11:00 a.m. to 11:04 a.m.\",\n      \"131\"= \"11:05 a.m. to 11:09 a.m.\",\n      \"145\"= \"12:15 p.m. to 12:19 p.m.\",\n      \"159\"= \"1:25 p.m. to 1:29 p.m.\",\n      \"168\"= \"2:10 p.m. to 2:14 p.m.\",\n      \"176\"= \"2:50 p.m. to 2:54 p.m.\",\n      \"188\"= \"3:50 p.m. to 3:54 p.m.\",\n      \"195\"= \"4:25 p.m. to 4:29 p.m.\",\n      \"213\"= \"5:55 p.m. to 5:59 p.m.\",\n      \"229\"= \"7:15 p.m. to 7:19 p.m.\",\n      \"231\"= \"7:25 p.m. to 7:29 p.m.\",\n      \"0\"= \"NA\"\n  )\n    \n    # Creating list of all possible values of JWDP\n    times_JWDP &lt;- c(\n     \"014\"= \"4:10 a.m. to 4:19 a.m.\",\n      \"015\"= \"4:20 a.m. to 4:29 a.m.\",\n      \"017\"= \"4:40 a.m. to 4:49 a.m.\",\n      \"022\"= \"5:15 a.m. to 5:19 a.m.\",\n      \"035\"= \"6:20 a.m. to 6:24 a.m.\",\n      \"046\"= \"7:15 a.m. to 7:19 a.m.\",\n      \"065\"= \"8:50 a.m. to 8:54 a.m.\",\n      \"068\"= \"9:05 a.m. to 9:09 a.m.\",\n      \"076\"= \"9:45 a.m. to 9:49 a.m.\",\n      \"079\"= \"10:00 a.m. to 10:09 a.m.\",\n      \"083\"= \"10:40 a.m. to 10:49 a.m.\",\n      \"085\"= \"11:00 a.m. to 11:09 a.m.\",\n      \"086\"= \"11:10 a.m. to 11:19 a.m.\",\n      \"103\"= \"2:00 p.m. to 2:09 p.m.\",\n      \"105\"= \"2:20 p.m. to 2:29 p.m.\",\n      \"118\"= \"4:30 p.m. to 4:39 p.m.\",\n      \"127\"= \"6:00 p.m. to 6:09 p.m.\",\n      \"130\"= \"6:30 p.m. to 6:39 p.m.\",\n      \"131\"= \"6:40 p.m. to 6:49 p.m.\",\n      \"139\"= \"9:20 p.m. to 9:29 p.m.\",\n      \"141\"= \"9:40 p.m. to 9:49 p.m.\",\n      \"149\"= \"11:00 p.m. to 11:29 p.m.\",\n      \"057\"= \"8:10 a.m. to 8:14 a.m.\",\n      \"059\"= \"8:20 a.m. to 8:24 a.m.\",\n      \"063\"= \"8:40 a.m. to 8:44 a.m.\",\n      \"066\"= \"8:55 a.m. to 8:59 a.m.\",\n      \"073\"= \"9:30 a.m. to 9:34 a.m.\",\n      \"078\"= \"9:55 a.m. to 9:59 a.m.\",\n      \"100\"= \"1:30 p.m. to 1:39 p.m.\",\n      \"101\"= \"1:40 p.m. to 1:49 p.m.\",\n      \"104\"= \"2:10 p.m. to 2:19 p.m.\",\n      \"107\"= \"2:40 p.m. to 2:49 p.m.\",\n      \"111\"= \"3:20 p.m. to 3:29 p.m.\",\n      \"116\"= \"4:10 p.m. to 4:19 p.m.\",\n      \"128\"= \"6:10 p.m. to 6:19 p.m.\",\n      \"150\"= \"11:30 p.m. to 11:59 p.m.\",\n      \"010\"= \"3:30 a.m. to 3:39 a.m.\",\n      \"011\"= \"3:40 a.m. to 3:49 a.m.\",\n      \"019\"= \"5:00 a.m. to 5:04 a.m.\",\n      \"028\"= \"5:45 a.m. to 5:49 a.m.\",\n      \"044\"= \"7:05 a.m. to 7:09 a.m.\",\n      \"045\"= \"7:10 a.m. to 7:14 a.m.\",\n      \"047\"= \"7:20 a.m. to 7:24 a.m.\",\n      \"049\"= \"7:30 a.m. to 7:34 a.m.\",\n      \"053\"= \"7:50 a.m. to 7:54 a.m.\",\n      \"055\"= \"8:00 a.m. to 8:04 a.m.\",\n      \"056\"= \"8:05 a.m. to 8:09 a.m.\",\n      \"084\"= \"10:50 a.m. to 10:59 a.m.\",\n      \"090\"= \"11:50 a.m. to 11:59 a.m.\",\n      \"092\"= \"12:10 p.m. to 12:19 p.m.\",\n      \"110\"= \"3:10 p.m. to 3:19 p.m.\",\n      \"112\"= \"3:30 p.m. to 3:39 p.m.\",\n      \"120\"= \"4:50 p.m. to 4:59 p.m.\",\n      \"132\"= \"6:50 p.m. to 6:59 p.m.\",\n      \"133\"= \"7:00 p.m. to 7:29 p.m.\",\n      \"134\"= \"7:30 p.m. to 7:59 p.m.\",\n      \"009\"= \"3:20 a.m. to 3:29 a.m.\",\n      \"023\"= \"5:20 a.m. to 5:24 a.m.\",\n      \"031\"= \"6:00 a.m. to 6:04 a.m.\",\n      \"038\"= \"6:35 a.m. to 6:39 a.m.\",\n      \"040\"= \"6:45 a.m. to 6:49 a.m.\",\n      \"050\"= \"7:35 a.m. to 7:39 a.m.\",\n      \"060\"= \"8:25 a.m. to 8:29 a.m.\",\n      \"062\"= \"8:35 a.m. to 8:39 a.m.\",\n      \"064\"= \"8:45 a.m. to 8:49 a.m.\",\n      \"067\"= \"9:00 a.m. to 9:04 a.m.\",\n      \"069\"= \"9:10 a.m. to 9:14 a.m.\",\n      \"082\"= \"10:30 a.m. to 10:39 a.m.\",\n      \"095\"= \"12:40 p.m. to 12:49 p.m.\",\n      \"096\"= \"12:50 p.m. to 12:59 p.m.\",\n      \"097\"= \"1:00 p.m. to 1:09 p.m.\",\n      \"119\"= \"4:40 p.m. to 4:49 p.m.\",\n      \"121\"= \"5:00 p.m. to 5:09 p.m.\",\n      \"135\"= \"8:00 p.m. to 8:29 p.m.\",\n      \"003\"= \"1:00 a.m. to 1:29 a.m.\",\n      \"033\"= \"6:10 a.m. to 6:14 a.m.\",\n      \"036\"= \"6:25 a.m. to 6:29 a.m.\",\n      \"041\"= \"6:50 a.m. to 6:54 a.m.\",\n      \"061\"= \"8:30 a.m. to 8:34 a.m.\",\n      \"081\"= \"10:20 a.m. to 10:29 a.m.\",\n      \"093\"= \"12:20 p.m. to 12:29 p.m.\",\n      \"098\"= \"1:10 p.m. to 1:19 p.m.\",\n      \"102\"= \"1:50 p.m. to 1:59 p.m.\",\n      \"109\"= \"3:00 p.m. to 3:09 p.m.\",\n      \"115\"= \"4:00 p.m. to 4:09 p.m.\",\n      \"126\"= \"5:50 p.m. to 5:59 p.m.\",\n      \"143\"= \"10:00 p.m. to 10:09 p.m.\",\n      \"145\"= \"10:20 p.m. to 10:29 p.m.\",\n      \"001\"= \"12:00 a.m. to 12:29 a.m.\",\n      \"006\"= \"2:30 a.m. to 2:59 a.m.\",\n      \"012\"= \"3:50 a.m. to 3:59 a.m.\",\n      \"013\"= \"4:00 a.m. to 4:09 a.m.\",\n      \"016\"= \"4:30 a.m. to 4:39 a.m.\",\n      \"025\"= \"5:30 a.m. to 5:34 a.m.\",\n      \"026\"= \"5:35 a.m. to 5:39 a.m.\",\n      \"030\"= \"5:55 a.m. to 5:59 a.m.\",\n      \"077\"= \"9:50 a.m. to 9:54 a.m.\",\n      \"087\"= \"11:20 a.m. to 11:29 a.m.\",\n      \"088\"= \"11:30 a.m. to 11:39 a.m.\",\n      \"094\"= \"12:30 p.m. to 12:39 p.m.\",\n      \"106\"= \"2:30 p.m. to 2:39 p.m.\",\n      \"108\"= \"2:50 p.m. to 2:59 p.m.\",\n      \"122\"= \"5:10 p.m. to 5:19 p.m.\",\n      \"123\"= \"5:20 p.m. to 5:29 p.m.\",\n      \"124\"= \"5:30 p.m. to 5:39 p.m.\",\n      \"144\"= \"10:10 p.m. to 10:19 p.m.\",\n      \"002\"= \"12:30 a.m. to 12:59 a.m.\",\n      \"004\"= \"1:30 a.m. to 1:59 a.m.\",\n      \"005\"= \"2:00 a.m. to 2:29 a.m.\",\n      \"007\"= \"3:00 a.m. to 3:09 a.m.\",\n      \"020\"= \"5:05 a.m. to 5:09 a.m.\",\n      \"021\"= \"5:10 a.m. to 5:14 a.m.\",\n      \"024\"= \"5:25 a.m. to 5:29 a.m.\",\n      \"027\"= \"5:40 a.m. to 5:44 a.m.\",\n      \"034\"= \"6:15 a.m. to 6:19 a.m.\",\n      \"039\"= \"6:40 a.m. to 6:44 a.m.\",\n      \"042\"= \"6:55 a.m. to 6:59 a.m.\",\n      \"043\"= \"7:00 a.m. to 7:04 a.m.\",\n      \"048\"= \"7:25 a.m. to 7:29 a.m.\",\n      \"051\"= \"7:40 a.m. to 7:44 a.m.\",\n      \"058\"= \"8:15 a.m. to 8:19 a.m.\",\n      \"072\"= \"9:25 a.m. to 9:29 a.m.\",\n      \"074\"= \"9:35 a.m. to 9:39 a.m.\",\n      \"075\"= \"9:40 a.m. to 9:44 a.m.\",\n      \"091\"= \"12:00 p.m. to 12:09 p.m.\",\n      \"113\"= \"3:40 p.m. to 3:49 p.m.\",\n      \"117\"= \"4:20 p.m. to 4:29 p.m.\",\n      \"125\"= \"5:40 p.m. to 5:49 p.m.\",\n      \"129\"= \"6:20 p.m. to 6:29 p.m.\",\n      \"136\"= \"8:30 p.m. to 8:59 p.m.\",\n      \"137\"= \"9:00 p.m. to 9:09 p.m.\",\n      \"140\"= \"9:30 p.m. to 9:39 p.m.\",\n      \"008\"= \"3:10 a.m. to 3:19 a.m.\",\n      \"018\"= \"4:50 a.m. to 4:59 a.m.\",\n      \"029\"= \"5:50 a.m. to 5:54 a.m.\",\n      \"032\"= \"6:05 a.m. to 6:09 a.m.\",\n      \"037\"= \"6:30 a.m. to 6:34 a.m.\",\n      \"052\"= \"7:45 a.m. to 7:49 a.m.\",\n      \"054\"= \"7:55 a.m. to 7:59 a.m.\",\n      \"070\"= \"9:15 a.m. to 9:19 a.m.\",\n      \"071\"= \"9:20 a.m. to 9:24 a.m.\",\n      \"080\"= \"10:10 a.m. to 10:19 a.m.\",\n      \"089\"= \"11:40 a.m. to 11:49 a.m.\",\n      \"099\"= \"1:20 p.m. to 1:29 p.m.\",\n      \"114\"= \"3:50 p.m. to 3:59 p.m.\",\n      \"138\"= \"9:10 p.m. to 9:19 p.m.\",\n      \"142\"= \"9:50 p.m. to 9:59 p.m.\",\n      \"146\"= \"10:30 p.m. to 10:39 p.m.\",\n      \"147\"= \"10:40 p.m. to 10:49 p.m.\",\n      \"148\"= \"10:50 p.m. to 10:59 p.m.\",\n       \"0\"= \"NA\"\n  )\n  \n  \n  # note sapply is discussed in week 8 (future material)\n  JWAP_label &lt;- sapply(times_JWAP, mid_time)\n  JWDP_label &lt;- sapply(times_JWDP, mid_time)\n  \n  # JWAP\n  if (\"JWAP\" %in% colnames(Census_info)) {\n    Census_info &lt;- Census_info |&gt;\n      mutate(JWAP = JWAP_label[JWAP])\n  }\n  \n  # JWDP\n  if (\"JWDP\" %in% colnames(Census_info)) {\n    Census_info &lt;- Census_info |&gt;\n      mutate(JWDP = JWDP_label[JWDP]) \n  }\n  \n  # From Data Manipulation step in instructions\n  class(Census_info) &lt;- c(\"census\",class(Census_info))\n  \n  return(Census_info)\n \n}\n\nNow that its built lets test calling it with the URL we used above.\n\nURL_funct(test_URL)\n\n# A tibble: 189 × 4\n   SEX    PWGTP MAR   SCHL            \n   &lt;fct&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt;           \n 1 Male      38 1     Doctorate degree\n 2 Female   120 1     Doctorate degree\n 3 Male      43 1     Doctorate degree\n 4 Female    25 2     Doctorate degree\n 5 Male      80 3     Doctorate degree\n 6 Male      83 1     Doctorate degree\n 7 Female   109 1     Doctorate degree\n 8 Male      74 1     Doctorate degree\n 9 Male      63 3     Doctorate degree\n10 Female    63 1     Doctorate degree\n# ℹ 179 more rows\n\n\nAwesome, now lets build our function to…"
  },
  {
    "objectID": "Proj1Code.html#query-the-census-api-and-return-a-table",
    "href": "Proj1Code.html#query-the-census-api-and-return-a-table",
    "title": "Project 1",
    "section": "Query the Census API and Return a Table",
    "text": "Query the Census API and Return a Table\nThe following function builds a URL for a single year of the API from user input and uses the previous function to make it a tibble. The code is divided into 2 main parts: logical qualifiers to align with project instructions and API limitations, and building a string to pass along to the generic URL function.\n\nQuoted URL String\nCreating a function to call on specified variables from the Census API. Method: passing along variables to a paste statement based on the following specifications\n\nContains a year between 2010-2022\nReturn at least 2 numeric variables: PUMS person weight (PWGTP) and at least 1 of the following\n\nAge (AGEP), Gas Cost (GASP), Gross rent as a percentage of household income (GRPIP), Time of arrival at work (JWAP), Time of departure from work (JWDP), Travel time to work (JWMNP)\n\nReturn at least 1 categorical variable\n\n(FER), (HHL), (HISPEED), (JWTRNS), (SCH), (SCHL), (SEX)\n\nOptional argument to subset the data based on geography (All, Regions, Divisions, or States)\n\n\nquery_api &lt;- function(year=2022, vars = c(\"PWGTP\"=NA, \"AGEP\"=NA, \"SEX\"=NA), geo_level = \"state\" , geo_code = 11){\n  # year = year of census to call, default is 2022\n  # vars = a vector of numerical and categorical indexes associated with their names default is PWGTP, AGEP, and SEX. The value NA means the variable is not going to be subsetted later.\n  # geo_level = geographic level Region, Division or State. The default is state  \n  # geo_code = geographic index code. The default is our group number, ours is 11\n  \n  # Logical Qualifiers\n  \n  # Making variable choices align with instructions\n  \n  #Empty for now\n  geo_str&lt;-\"\"\n  \n  # User input to upper/lower case\n  # i made geo lower case because thats how it is in url\n  names(vars) &lt;- toupper(names(vars))\n  geo_level &lt;- tolower(geo_level)\n  \n  # All variable options\n  n_valid_vars &lt;- c(\"PWGTP\", \"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\")\n  c_valid_vars &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n  valid_level &lt;- c(\"region\", \"division\", \"state\", \"all\")\n  \n  # Keep only those that appear in both the argument and valid variables based on the instruction\n  n_var_names &lt;- intersect(names(vars), n_valid_vars)\n  c_var_names &lt;- intersect(names(vars), c_valid_vars)\n  geo_name &lt;- intersect(geo_level, valid_level)\n  \n  # Creating tibble of valid n and c var limits based on variable information site\n  var_limits &lt;- data.frame(names = c(n_valid_vars[-which(names(vars) == \"PWGTP\")], c_valid_vars), \n                          lower_bound = c(0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1), \n                          upper_bound = c(99, 9999, 101, 285, 150, 200, 2, 5, 2, 12, 3, 24, 2))\n  \n  # This checks that year is numeric or not multiple years and between '10 and '22. It then checks that it is in the valid range and filters out the year 2020, where there is no data\n  if (!is.numeric(year) | length(year) != 1){\n    stop(\"Warning: Year must be a single numeric value\")\n  } else if(year &gt; 2022 | year &lt; 2010){\n    stop(\"Warning: Year must be between 2010-2022\")\n  } else if(year == 2020){\n    stop(\"Warning: The year 2020 has no data\")\n  }\n  \n  # filtering out variables from forum that if they are not in certain year\n  if (\"JWTRNS\" %in% c_var_names & year &lt; 2019){\n    stop(\"Warning: JWTRNS was not recorded in the year provided\")\n  } \n  \n  if (\"HISPEED\" %in% c_var_names & year &lt; 2016){\n    stop(\"Warning: HISPEED was not recorded in the year provided\")\n  }\n  \n  # Checks that at least 1 of numerical and categorical vars in the argument are valid\n  # Double as the check that there is at least 1 categorical\n  if (length(n_var_names) == 0 | length(c_var_names) == 0){\n    stop(\"Warning: One or more variables are invalid or not enough variables as argument\")\n  } \n  \n  # Giving note if one of the variable calls is invalid and subsetting to valid variables\n  if ((length(n_var_names) + length(c_var_names)) &lt; length(names(vars))){\n      print(\"Note: One or more variables are invalid, returning only valid variables\")\n    vars &lt;- vars[c(n_var_names, c_var_names)]\n  }\n\n  # PWGTP always included and at least one other numeric var\n  if (length(n_var_names) &lt; 2 | !(\"PWGTP\" %in% n_var_names)){\n    stop(\"Warning: PWGTP and at least 1 other valid numerical vector must be an argument\")\n  }\n  \n  # Assigning valid geo code based on selected region. \n  # If all is selected as geo_level, the variables get turned into normal columns. Hence the change from lower to upper case and state becoming ST.\n  if (geo_name == \"region\"){\n    valid_code &lt;- c(1:4)\n  } else if (geo_name == \"division\"){\n      valid_code &lt;- c(1:9)\n  } else if (geo_name == \"state\"){\n      valid_code &lt;- c(1:56)[-c(3, 7, 14, 43, 52)] \n  } else{\n    geo_name &lt;- c(\"REGION\", \"DIVISION\", \"ST\") \n    geo_code = \"*\"\n  }\n  \n  # Making sure valid geo_code was given\n  if (!(geo_code == \"*\" || geo_code == round(geo_code))){\n    stop('Warning: geo_code must be an integer or \"*\"') \n  }\n  \n  # Assigning valid indexes for variables\n  #Cannot be indexed: PWGTP\n  for (i in 1:length(vars[-which(names(vars) == \"PWGTP\")])){\n    if (!is.na(vars[i])){\n      \n      # Making sure given subset is an integer\n      if (vars[i] != round(vars[i])){\n        stop(\"Given subset must be an integer\")\n      }\n      \n      # Checking if given subset is within the bounds of the subset\n      if (var_limits$lower_bound[which(var_limits$names == names(vars[i]))] &gt; vars[i] | var_limits$upper_bound[which(var_limits$names == names(vars[i]))] &lt; vars[i]){\n        print(paste(\"Invalid Variable Subsetting. Returning all values of variable\", names(vars[i])))\n        vars[i] = NA\n      } else if ((names(vars[i]) %in% n_var_names) & !(names(vars[i]) %in% c(\"JWAP\", \"JWDP\"))){\n        # Since these variables are given as ranges on the API site, there is no way to know if a specific value exists \n          print(\"Note: Numerical variable subsetted. While within the given range, Specific number may not be in the data\")\n      }\n    }\n  }\n  \n  # Fill in geo_str \n  \n  if(length(geo_name) &gt; 1){ \n    geo_str &lt;- paste0(geo_name, collapse=,)\n  } else if (geo_level %in% valid_level && ((geo_code %in% valid_code) | geo_code == \"*\")){\n      geo_str&lt;-paste0(\"&for=\", geo_level, \":\" ,geo_code)\n  } else if (!(geo_level %in% valid_geo & geo_level != \"all\")){\n      stop(\"Warning: Provided geography level is not valid\")\n  } else if (!(geo_code %in% valid_code)){\n      stop(\"Warning: Provided geography code is not valid for your geography level\")\n  }\n\n  \n # Creating master URL. The string is constructed differently based on whether or not there are any variables indexed or if the given geo_level was all (length(geo_name) &gt; 1). Therefore, the api is built within the if then else statme\n if(!all(is.na(vars))){\n   if(length(geo_name) &gt; 1){\n     api_url &lt;- paste0(\"https://api.census.gov/data/\", year, \"/acs/acs1/pums?get=\", \n                      paste(names(vars)[is.na(vars)], collapse=\",\"), geo_str, \"&\",\n                      paste0(names(vars)[!is.na(vars)], \"=\", vars[!is.na(vars)], collapse=\"&\"))\n   } else{\n     api_url &lt;- paste0(\"https://api.census.gov/data/\", year, \"/acs/acs1/pums?get=\", \n                      paste(names(vars)[is.na(vars)], collapse=\",\"), \"&\",\n                      paste0(names(vars)[!is.na(vars)], \"=\", vars[!is.na(vars)], collapse=\"&\"), geo_str)\n   }\n } else{\n    api_url &lt;- paste0(\"https://api.census.gov/data/\", year, \"/acs/acs1/pums?get=\", \n                      paste(names(vars)[is.na(vars)], collapse=\",\"), geo_str)\n }\n    \n  return(URL_funct(api_url))\n\n  \n}\n\nWe want to test that our function to query and API worked!\n\nCensus_tibble &lt;- query_api(vars = c(PWGTP = NA, GASP=3, SEX = NA))\n\n[1] \"Note: Numerical variable subsetted. While within the given range, Specific number may not be in the data\"\n\n# does our function address 001 vs 1 vs 01 for jwdp?\n# I just tested it in a URL and 001, 1, and 01 all return the same thing.\n\nCensus_tibble\n\n# A tibble: 3,144 × 4\n   PWGTP SEX     GASP state\n   &lt;dbl&gt; &lt;fct&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1    72 Female     3 11   \n 2    90 Male       3 11   \n 3   183 Female     3 11   \n 4   114 Female     3 11   \n 5   184 Male       3 11   \n 6   155 Male       3 11   \n 7   149 Female     3 11   \n 8    66 Female     3 11   \n 9    54 Male       3 11   \n10    55 Male       3 11   \n# ℹ 3,134 more rows"
  },
  {
    "objectID": "Proj1Code.html#creating-table-that-spans-multiple-years",
    "href": "Proj1Code.html#creating-table-that-spans-multiple-years",
    "title": "Project 1",
    "section": "Creating Table that Spans Multiple Years",
    "text": "Creating Table that Spans Multiple Years\nLast Data processing function. Specifies multiple years of survey data while keeping the rest of the variables constatnt\n\nbuild_multi_year_tbl &lt;- function(years = c(2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2021, 2022), vars = c(\"PWGTP\"=NA, \"AGEP\"=NA, \"SEX\"=NA), geo_level = \"state\" , geo_code = 11){\n  \n  if (any(years &gt; 2022) | any(years &lt; 2010) | any(years == 2020)){\n    stop(\"Warning: Year must be between 2010-2022 and not 2020\")\n  }\n  \n  if (\"JWTRNS\" %in% names(vars) & any(years &lt; 2019)){\n    stop(\"Warning: JWTRNS only recorded in years greater than 2019\")\n  } \n  \n  if (\"HISPEED\" %in% names(vars) & any(years &lt; 2016)){\n    stop(\"Warning: HISPEED was not recorded in the year provided\")\n  }\n  \n  multi_year_tbl = tibble()\n  for (i in 1:length(years)){\n    temp &lt;- query_api(years[i], vars, geo_level, geo_code) |&gt;\n        mutate(\n          year = years[i],\n          .before = 1\n        )\n    multi_year_tbl &lt;- bind_rows(multi_year_tbl, temp)\n  }\n  \n  return(multi_year_tbl)\n  \n}\n\nWe want to test that our function to make a table with multiple years worked\n\nyrs = c(2012, 2013, 2021)\nmulti_yr_tbl &lt;- build_multi_year_tbl(years = yrs)\nmulti_yr_tbl\n\n# A tibble: 20,037 × 5\n    year PWGTP  AGEP SEX    state\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;chr&gt;\n 1  2012    40    87 Female 11   \n 2  2012    68    43 Female 11   \n 3  2012    74    19 Male   11   \n 4  2012    56    12 Male   11   \n 5  2012    81    58 Female 11   \n 6  2012   119    23 Female 11   \n 7  2012    65    93 Female 11   \n 8  2012    98    48 Female 11   \n 9  2012     9    93 Female 11   \n10  2012   192    46 Female 11   \n# ℹ 20,027 more rows"
  },
  {
    "objectID": "Proj1Code.html#generic-function-for-summarizing.",
    "href": "Proj1Code.html#generic-function-for-summarizing.",
    "title": "Project 1",
    "section": "Generic function for summarizing.",
    "text": "Generic function for summarizing.\nWe went back to the generalized function (URL_funct) to build a table from an API URL to input the code to add a class to the census data for summarizing purposes. The code instructions on our tester table would look like\n\nclass(Census_tibble) &lt;- c(“census”,class(Census_tibble))\n\nThe summarizing function will produce the means and standard deviations for specified numeric variables and the counts for specified categorical variables. The arguments would be the tibble produced from URL_funct, and the numeric and categorical variables to summarize. The numeric variables are weighted based on the peron weight vector, PWGTP.\n\n# summarizing function\nsummarize_census &lt;- function(tibble, num_vars=NULL, cat_vars=NULL){\n  # tibble we are using\n  # num_vars are our numeric variables we want to summarize\n  # cat_vars are our categorical variables we want to summarize\n  # we did NULL default so we can use if logic later to return all\n  \n  # empty list for later\n  results &lt;- list()\n  \n  weight &lt;- as.numeric(tibble$PWGTP)\n  \n  #numeric \n  \n  # return all numeric names except PWGTP\n  all_num &lt;- tibble |&gt;\n    select(where(is.numeric), -PWGTP) |&gt;\n    names()\n  \n  # Keep only those that appear in both\n  num_vars &lt;- intersect(num_vars, all_num)\n  \n  # give us all numeric variables if none given\n  if (is.null(num_vars)){\n    num_vars &lt;- all_num\n  }\n  \n  # loop to go through this vector and compute mean and standard deviation\n  # note: Given outline code for this. Replace x^2 with x*x\n  for (i in num_vars){\n    x &lt;- tibble[[i]]\n    x_mean &lt;- sum(x*weight)/sum(weight)\n    x_sd &lt;- sqrt(sum(x*x*weight)/sum(weight)-(x_mean*x_mean))\n    results[[i]] &lt;- list(mean = x_mean, sd = x_sd)\n  }\n  \n  # categorical\n  \n  # return all categorical names\n  all_cat &lt;- tibble |&gt;\n  select(where(is.character), where(is.factor)) |&gt;\n  names()\n  \n  # Keep only those that appear in both\n  cat_vars &lt;- intersect(cat_vars, all_cat)\n  \n  # give us all categorical variables if none given\n  if (is.null(cat_vars)){\n    cat_vars &lt;- all_cat\n  } \n  \n  # loop to go through this vector and compute counts\n  # tapply is base R read through the documentation on it in the help tab\n  for (i in cat_vars){\n    counts &lt;- tapply(weight, tibble[[i]],sum)  \n    results[[i]] &lt;- as.list(counts)\n  }\n  \n  return(results)\n}\n\nWe are now going to test our summary function! We used the test tibble from when we tested our API query!\n\n#test for this function\nsummarize_census(Census_tibble, \"GASP\", \"SEX\")\n\n$GASP\n$GASP$mean\n[1] 3\n\n$GASP$sd\n[1] 0\n\n\n$SEX\n$SEX$Male\n[1] 156399\n\n$SEX$Female\n[1] 179066"
  },
  {
    "objectID": "Proj1Code.html#plotting-function",
    "href": "Proj1Code.html#plotting-function",
    "title": "Project 1",
    "section": "Plotting Function",
    "text": "Plotting Function\nNext we will create our plot function. We are requiring to user to specify one categorical and one numeric variable for plotting purposes.\n\nplot_Census &lt;- function(tibble , num_var , cat_var){\n  \n  # valid num\n  all_num &lt;- tibble |&gt;\n  select(where(is.numeric), -PWGTP) |&gt;\n  names()\n  \n  # valid cat\n  all_cat &lt;- tibble |&gt;\n  select(where(is.character), where(is.factor)) |&gt;\n  names()\n  \n  # to uppercase\n  names(num_var) &lt;- toupper(names(num_var))\n  names(cat_var) &lt;- toupper(names(cat_var))\n  \n  # only one cat or num variable\n  if (length(cat_var) != 1 | length(num_var) != 1) {\n    stop(\"Warning: Please specify one categorical and one numeric variable.\")\n  } else if (!(cat_var %in% all_cat) || !(num_var %in% all_num)){\n    stop(\"Warning: Invalid categorical or numeric variable specified\")\n  }\n  \n  # this code was given\n  ggplot(tibble,\n    # aes_string(x = cat_var, y = num_var, weight = \"PWGTP\")) + geom_boxplot()\n    aes(x = get(cat_var), y = get(num_var), weight = as.numeric(PWGTP))) + geom_boxplot() + \n    xlab(cat_var) + ylab(num_var) +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n}\n\nNow we will test our function for plots works! Again we will use test tibble from testing our API query.\n\nplot_Census(Census_tibble, \"GASP\", \"SEX\")\n\n\n\n\nThis example was not very informative because the value of GASP is 3 for the specified qualifiers. For the following code chunk we will use our functions to build a plot based on Household Language and Age\n\nplot_Census(query_api(vars = c(PWGTP = NA, AGEP = NA, HHL = NA)), \"AGEP\", \"HHL\")"
  }
]