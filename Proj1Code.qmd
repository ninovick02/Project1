---
title: "Project 1"
format: html
editor: visual
---

### Authors: Naomi Novick & Elle Whitlock

### Date: 2025-10-01

### Purpose: ST558 Project 1

#### Investigating code sourced from the US census API

# Introduction

In this document, we will write functions that will manipulate, process, and plot data from a [census API](https://data.census.gov/app/mdat/#). The following document is divided into parts: Data, Manipulation, and Investigation. We will be Data Processing, Obtaining Person Level Records, Writing a Generic Function for Summarizing, and Writing a Function for Plotting. For each major function, there will be a sample function call. We will then investigate something interesting about the data.

## Loading libraries

Setting up the needed packages for this project. Note please make sure you install these packages in your console before calling them with the library statement!

```{r}
# Libraries we need 
# For various parts of building our functions
library("tidyverse")
# To query API
library("httr")
library("jsonlite")
# time mid pt function
library("hms")
```

# Data

## Creating Table from a given API URL

The first step in our homework is to try and query an API. I chose a random URL to **test** before we get into our function writing.

```{r}
# I am setting up trial url
test_URL <- "https://api.census.gov/data/2012/acs/acs1/pumspr?get=SEX,PWGTP,MAR&SCHL=24"
raw_info <-GET(test_URL)
parsed <- fromJSON(rawToChar(raw_info$content))
# The first row is column names so we have to adjust 
test_info <- as_tibble(parsed[-1,])
colnames(test_info) <- parsed[1,] 
test_info
```

## Creating Generalized Function to turn API URL to a Table

If you click on the link it looks like our code worked great!

### Helper Function to Determine Time Variable Mid Points

We will now define a function to help us determine mid point for time intervals of the form "9:15 a.m. to 9:19 a.m." which happens in the variables JWAP and JWDP. Our function should return 9:17 AM.

```{r}
# function to do mid point of time

mid_time <- function(time) {
  if (time == "NA" || time == "0") {
    return(NA)
  }
  
  # Split interval into start and end times
  parts <- str_split(time, " to ", simplify = TRUE)
  start <- parts[1]
  end   <- parts[2]
  
  # ran into issue because hms uses AM PM with no dots, this cleans it
  start <- str_replace_all(start, c("a.m." = "AM", "p.m." = "PM"))
  end   <- str_replace_all(end,   c("a.m." = "AM", "p.m." = "PM"))
  
  # using hms (time format) because of forum Dr. Post mentioned it
  start_hms <- as_hms(strptime(start, format = "%I:%M %p"))
  end_hms   <- as_hms(strptime(end,   format = "%I:%M %p"))

  # Compute midpoint via average seconds between start and end
  # note we were told we can round to get it to the minute only
  mid_secs <- (as.numeric(start_hms) + as.numeric(end_hms)) / 2
  mid_secs <- round(mid_secs / 60)*60
  
  # back to time format
  mid_hms  <- as_hms(mid_secs)
  
  # back to character, display only hours mins and am/pm
  # Dr. Post said this its okay to be character
  out <- format(strptime(as.character(mid_hms), "%H:%M:%S"), "%I:%M %p")
  
  return(out)
}

```

Were going to **test** that our function for mid point in time works with the example we mentioned above!

```{r}
mid_time("9:15 a.m. to 9:19 a.m.")
```

Great, now lets work on the second step, writing a helper function to iterate this process.

### Generalized Helper function

Here we have to make sure categorical variables that coded with strings of numbers get converted to the correct information via the mutate and factor. We must make sure numeric variables are numeric, and finally we have to make sure our time variables return the middle of the time period.

```{r}
# This assumes valid URL is used and has the same structure as our above example if our other function is thorough enough then this should not be an issue. 
URL_funct <-function(Census_URL){ 
  raw_info <-GET(Census_URL)
  parsed <-fromJSON(rawToChar(raw_info$content))
  Census_info <- as_tibble(parsed[-1,])
  colnames(Census_info) <- parsed[1,] 
  
  
  # Turn categorical variables into factors with the appropriate levels using if logic to see if the column is in our tibble
  
  # FER
  if ("FER" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
     mutate(FER = factor(as.numeric(FER), levels = c(0:2), labels = c("N/A (less than 15 years/greater than 50 years/ male)", "No", "Yes")))
  }  
  
  # HHL
    if ("HHL" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
     mutate(HHL = factor(as.numeric(HHL), levels = c(0:5), labels = c("N/A (GQ/Vacant)", "Spanish","Other Indo-European languages", "English Only","Asian and Pacific Island languages", "Other Language")))
    }  
  
   # HISPEED 
  if ("HISPEED" %in% colnames(Census_info)) {
     Census_info <- Census_info |>
       mutate(HISPEED = factor(as.numeric(HISPEED), levels = c(0:2), labels = c("N/A (GQ/vacant/no paid access to internet)", "Yes", "No")))
  }
  

  # JWTRNS
  if ("JWTRNS" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
     mutate(JWTRNS = factor(as.numeric(JWTRNS), levels = (0:12),
                          labels = c("N/A (not a worker-not in the labor force, including persons under 16 years; unemployed; employed, with a job but not at work; Armed Forces, with a job but not at work)","Car, truck, or van","Bus","Subway or elevated rail","Long-distance train or commuter rail","Light rail, streetcar, or trolley","Ferryboat","Taxicab","Motorcycle","Bicycle","Walked","Worked from home","Other method")))
  }
  # SCH
  if ("SCH" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
      mutate(SCH = factor(as.numeric(SCH), levels = 0:2,labels = c("N/A (less than 3 years old)","No, has not attended in the last 3 months","Yes, public school or public college","Yes, private school or college or home school"))) 
  }
  
  # SCHL (education)
  if ("SCHL" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
      mutate(SCHL = factor(as.numeric(SCHL),levels = (0:24),labels = c("N/A (less than 3 years old)", "No schooling completed","Nursery school, preschool","Kindergarten","Grade 1","Grade 2","Grade 3","Grade 4","Grade 5","Grade 6","Grade 7","Grade 8","Grade 9","Grade 10","Grade 11","12th grade - no diploma","Regular high school diploma","GED or alternative credential","Some college, but less than 1 year","1 or more years of college credit, no degree","Associate's degree","Bachelor's degree","Master's degree","Professional degree beyond a bachelor's degree","Doctorate degree")))
  }
  
  # SEX
  if ("SEX" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
      mutate(SEX = factor(as.numeric(SEX), levels = c(1:2),labels = c("Male", "Female")))
  }
  
  # Next convert numeric variables with similar if logic to check if they are in tibble we can loop through this
  
  num_vars <- c("AGEP", "GASP", "GRPIP", "JWMNP", "PWGTP")

  for (i in num_vars) {
    if (i %in% colnames(Census_info)) {
    Census_info[[i]] <- as.numeric(Census_info[[i]])
    }
  }
  
  
  # taken from Census API site with : swapped for =
  # Creating list of all possible values of JWAP
  # We will use the midtime function on this and the JWDP list to create all possible factor levels for these variables
  times_JWAP <-c(
      "258"= "9:40 p.m. to 9:44 p.m.",
      "260"= "9:50 p.m. to 9:54 p.m.",
      "261"= "9:55 p.m. to 9:59 p.m.",
      "274"= "11:00 p.m. to 11:04 p.m.",
      "048"= "4:10 a.m. to 4:14 a.m.",
      "058"= "5:00 a.m. to 5:04 a.m.",
      "076"= "6:30 a.m. to 6:34 a.m.",
      "091"= "7:45 a.m. to 7:49 a.m.",
      "094"= "8:00 a.m. to 8:04 a.m.",
      "122"= "10:20 a.m. to 10:24 a.m.",
      "142"= "12:00 p.m. to 12:04 p.m.",
      "146"= "12:20 p.m. to 12:24 p.m.",
      "163"= "1:45 p.m. to 1:49 p.m.",
      "165"= "1:55 p.m. to 1:59 p.m.",
      "171"= "2:25 p.m. to 2:29 p.m.",
      "184"= "3:30 p.m. to 3:34 p.m.",
      "189"= "3:55 p.m. to 3:59 p.m.",
      "192"= "4:10 p.m. to 4:14 p.m.",
      "198"= "4:40 p.m. to 4:44 p.m.",
      "210"= "5:40 p.m. to 5:44 p.m.",
      "218"= "6:20 p.m. to 6:24 p.m.",
      "220"= "6:30 p.m. to 6:34 p.m.",
      "221"= "6:35 p.m. to 6:39 p.m.",
      "222"= "6:40 p.m. to 6:44 p.m.",
      "224"= "6:50 p.m. to 6:54 p.m.",
      "227"= "7:05 p.m. to 7:09 p.m.",
      "228"= "7:10 p.m. to 7:14 p.m.",
      "251"= "9:05 p.m. to 9:09 p.m.",
      "256"= "9:30 p.m. to 9:34 p.m.",
      "259"= "9:45 p.m. to 9:49 p.m.",
      "262"= "10:00 p.m. to 10:04 p.m.",
      "270"= "10:40 p.m. to 10:44 p.m.",
      "271"= "10:45 p.m. to 10:49 p.m.",
      "276"= "11:10 p.m. to 11:14 p.m.",
      "284"= "11:50 p.m. to 11:54 p.m.",
      "006"= "12:25 a.m. to 12:29 a.m.",
      "008"= "12:40 a.m. to 12:44 a.m.",
      "009"= "12:45 a.m. to 12:49 a.m.",
      "011"= "1:00 a.m. to 1:04 a.m.",
      "017"= "1:30 a.m. to 1:34 a.m.",
      "020"= "1:45 a.m. to 1:49 a.m.",
      "031"= "2:45 a.m. to 2:49 a.m.",
      "039"= "3:25 a.m. to 3:29 a.m.",
      "053"= "4:35 a.m. to 4:39 a.m.",
      "065"= "5:35 a.m. to 5:39 a.m.",
      "075"= "6:25 a.m. to 6:29 a.m.",
      "085"= "7:15 a.m. to 7:19 a.m.",
      "090"= "7:40 a.m. to 7:44 a.m.",
      "101"= "8:35 a.m. to 8:39 a.m.",
      "107"= "9:05 a.m. to 9:09 a.m.",
      "121"= "10:15 a.m. to 10:19 a.m.",
      "124"= "10:30 a.m. to 10:34 a.m.",
      "137"= "11:35 a.m. to 11:39 a.m.",
      "156"= "1:10 p.m. to 1:14 p.m.",
      "164"= "1:50 p.m. to 1:54 p.m.",
      "173"= "2:35 p.m. to 2:39 p.m.",
      "197"= "4:35 p.m. to 4:39 p.m.",
      "202"= "5:00 p.m. to 5:04 p.m.",
      "234"= "7:40 p.m. to 7:44 p.m.",
      "235"= "7:45 p.m. to 7:49 p.m.",
      "246"= "8:40 p.m. to 8:44 p.m.",
      "249"= "8:55 p.m. to 8:59 p.m.",
      "257"= "9:35 p.m. to 9:39 p.m.",
      "273"= "10:55 p.m. to 10:59 p.m.",
      "277"= "11:15 p.m. to 11:19 p.m.",
      "002"= "12:05 a.m. to 12:09 a.m.",
      "004"= "12:15 a.m. to 12:19 a.m.",
      "015"= "1:20 a.m. to 1:24 a.m.",
      "034"= "3:00 a.m. to 3:04 a.m.",
      "035"= "3:05 a.m. to 3:09 a.m.",
      "042"= "3:40 a.m. to 3:44 a.m.",
      "044"= "3:50 a.m. to 3:54 a.m.",
      "050"= "4:20 a.m. to 4:24 a.m.",
      "052"= "4:30 a.m. to 4:34 a.m.",
      "055"= "4:45 a.m. to 4:49 a.m.",
      "069"= "5:55 a.m. to 5:59 a.m.",
      "071"= "6:05 a.m. to 6:09 a.m.",
      "077"= "6:35 a.m. to 6:39 a.m.",
      "079"= "6:45 a.m. to 6:49 a.m.",
      "082"= "7:00 a.m. to 7:04 a.m.",
      "089"= "7:35 a.m. to 7:39 a.m.",
      "092"= "7:50 a.m. to 7:54 a.m.",
      "093"= "7:55 a.m. to 7:59 a.m.",
      "097"= "8:15 a.m. to 8:19 a.m.",
      "117"= "9:55 a.m. to 9:59 a.m.",
      "118"= "10:00 a.m. to 10:04 a.m.",
      "129"= "10:55 a.m. to 10:59 a.m.",
      "132"= "11:10 a.m. to 11:14 a.m.",
      "138"= "11:40 a.m. to 11:44 a.m.",
      "144"= "12:10 p.m. to 12:14 p.m.",
      "148"= "12:30 p.m. to 12:34 p.m.",
      "150"= "12:40 p.m. to 12:44 p.m.",
      "152"= "12:50 p.m. to 12:54 p.m.",
      "166"= "2:00 p.m. to 2:04 p.m.",
      "181"= "3:15 p.m. to 3:19 p.m.",
      "183"= "3:25 p.m. to 3:29 p.m.",
      "205"= "5:15 p.m. to 5:19 p.m.",
      "219"= "6:25 p.m. to 6:29 p.m.",
      "230"= "7:20 p.m. to 7:24 p.m.",
      "233"= "7:35 p.m. to 7:39 p.m.",
      "239"= "8:05 p.m. to 8:09 p.m.",
      "244"= "8:30 p.m. to 8:34 p.m.",
      "254"= "9:20 p.m. to 9:24 p.m.",
      "265"= "10:15 p.m. to 10:19 p.m.",
      "272"= "10:50 p.m. to 10:54 p.m.",
      "013"= "1:10 a.m. to 1:14 a.m.",
      "014"= "1:15 a.m. to 1:19 a.m.",
      "019"= "1:40 a.m. to 1:44 a.m.",
      "022"= "2:00 a.m. to 2:04 a.m.",
      "033"= "2:55 a.m. to 2:59 a.m.",
      "037"= "3:15 a.m. to 3:19 a.m.",
      "041"= "3:35 a.m. to 3:39 a.m.",
      "059"= "5:05 a.m. to 5:09 a.m.",
      "067"= "5:45 a.m. to 5:49 a.m.",
      "068"= "5:50 a.m. to 5:54 a.m.",
      "074"= "6:20 a.m. to 6:24 a.m.",
      "080"= "6:50 a.m. to 6:54 a.m.",
      "084"= "7:10 a.m. to 7:14 a.m.",
      "088"= "7:30 a.m. to 7:34 a.m.",
      "095"= "8:05 a.m. to 8:09 a.m.",
      "100"= "8:30 a.m. to 8:34 a.m.",
      "125"= "10:35 a.m. to 10:39 a.m.",
      "140"= "11:50 a.m. to 11:54 a.m.",
      "172"= "2:30 p.m. to 2:34 p.m.",
      "178"= "3:00 p.m. to 3:04 p.m.",
      "182"= "3:20 p.m. to 3:24 p.m.",
      "185"= "3:35 p.m. to 3:39 p.m.",
      "187"= "3:45 p.m. to 3:49 p.m.",
      "199"= "4:45 p.m. to 4:49 p.m.",
      "206"= "5:20 p.m. to 5:24 p.m.",
      "208"= "5:30 p.m. to 5:34 p.m.",
      "209"= "5:35 p.m. to 5:39 p.m.",
      "243"= "8:25 p.m. to 8:29 p.m.",
      "268"= "10:30 p.m. to 10:34 p.m.",
      "269"= "10:35 p.m. to 10:39 p.m.",
      "279"= "11:25 p.m. to 11:29 p.m.",
      "001"= "12:00 a.m. to 12:04 a.m.",
      "005"= "12:20 a.m. to 12:24 a.m.",
      "007"= "12:30 a.m. to 12:39 a.m.",
      "023"= "2:05 a.m. to 2:09 a.m.",
      "025"= "2:15 a.m. to 2:19 a.m.",
      "029"= "2:35 a.m. to 2:39 a.m.",
      "036"= "3:10 a.m. to 3:14 a.m.",
      "043"= "3:45 a.m. to 3:49 a.m.",
      "046"= "4:00 a.m. to 4:04 a.m.",
      "051"= "4:25 a.m. to 4:29 a.m.",
      "056"= "4:50 a.m. to 4:54 a.m.",
      "073"= "6:15 a.m. to 6:19 a.m.",
      "081"= "6:55 a.m. to 6:59 a.m.",
      "098"= "8:20 a.m. to 8:24 a.m.",
      "103"= "8:45 a.m. to 8:49 a.m.",
      "106"= "9:00 a.m. to 9:04 a.m.",
      "114"= "9:40 a.m. to 9:44 a.m.",
      "135"= "11:25 a.m. to 11:29 a.m.",
      "143"= "12:05 p.m. to 12:09 p.m.",
      "149"= "12:35 p.m. to 12:39 p.m.",
      "157"= "1:15 p.m. to 1:19 p.m.",
      "158"= "1:20 p.m. to 1:24 p.m.",
      "160"= "1:30 p.m. to 1:34 p.m.",
      "170"= "2:20 p.m. to 2:24 p.m.",
      "174"= "2:40 p.m. to 2:44 p.m.",
      "179"= "3:05 p.m. to 3:09 p.m.",
      "194"= "4:20 p.m. to 4:24 p.m.",
      "196"= "4:30 p.m. to 4:34 p.m.",
      "211"= "5:45 p.m. to 5:49 p.m.",
      "212"= "5:50 p.m. to 5:54 p.m.",
      "214"= "6:00 p.m. to 6:04 p.m.",
      "241"= "8:15 p.m. to 8:19 p.m.",
      "264"= "10:10 p.m. to 10:14 p.m.",
      "266"= "10:20 p.m. to 10:24 p.m.",
      "016"= "1:25 a.m. to 1:29 a.m.",
      "018"= "1:35 a.m. to 1:39 a.m.",
      "021"= "1:50 a.m. to 1:59 a.m.",
      "028"= "2:30 a.m. to 2:34 a.m.",
      "054"= "4:40 a.m. to 4:44 a.m.",
      "060"= "5:10 a.m. to 5:14 a.m.",
      "064"= "5:30 a.m. to 5:34 a.m.",
      "070"= "6:00 a.m. to 6:04 a.m.",
      "078"= "6:40 a.m. to 6:44 a.m.",
      "087"= "7:25 a.m. to 7:29 a.m.",
      "105"= "8:55 a.m. to 8:59 a.m.",
      "111"= "9:25 a.m. to 9:29 a.m.",
      "119"= "10:05 a.m. to 10:09 a.m.",
      "123"= "10:25 a.m. to 10:29 a.m.",
      "126"= "10:40 a.m. to 10:44 a.m.",
      "134"= "11:20 a.m. to 11:24 a.m.",
      "139"= "11:45 a.m. to 11:49 a.m.",
      "141"= "11:55 a.m. to 11:59 a.m.",
      "151"= "12:45 p.m. to 12:49 p.m.",
      "153"= "12:55 p.m. to 12:59 p.m.",
      "169"= "2:15 p.m. to 2:19 p.m.",
      "180"= "3:10 p.m. to 3:14 p.m.",
      "203"= "5:05 p.m. to 5:09 p.m.",
      "204"= "5:10 p.m. to 5:14 p.m.",
      "207"= "5:25 p.m. to 5:29 p.m.",
      "215"= "6:05 p.m. to 6:09 p.m.",
      "216"= "6:10 p.m. to 6:14 p.m.",
      "217"= "6:15 p.m. to 6:19 p.m.",
      "223"= "6:45 p.m. to 6:49 p.m.",
      "225"= "6:55 p.m. to 6:59 p.m.",
      "247"= "8:45 p.m. to 8:49 p.m.",
      "248"= "8:50 p.m. to 8:54 p.m.",
      "252"= "9:10 p.m. to 9:14 p.m.",
      "253"= "9:15 p.m. to 9:19 p.m.",
      "255"= "9:25 p.m. to 9:29 p.m.",
      "263"= "10:05 p.m. to 10:09 p.m.",
      "267"= "10:25 p.m. to 10:29 p.m.",
      "278"= "11:20 p.m. to 11:24 p.m.",
      "280"= "11:30 p.m. to 11:34 p.m.",
      "281"= "11:35 p.m. to 11:39 p.m.",
      "282"= "11:40 p.m. to 11:44 p.m.",
      "003"= "12:10 a.m. to 12:14 a.m.",
      "010"= "12:50 a.m. to 12:59 a.m.",
      "038"= "3:20 a.m. to 3:24 a.m.",
      "049"= "4:15 a.m. to 4:19 a.m.",
      "057"= "4:55 a.m. to 4:59 a.m.",
      "061"= "5:15 a.m. to 5:19 a.m.",
      "062"= "5:20 a.m. to 5:24 a.m.",
      "072"= "6:10 a.m. to 6:14 a.m.",
      "083"= "7:05 a.m. to 7:09 a.m.",
      "104"= "8:50 a.m. to 8:54 a.m.",
      "108"= "9:10 a.m. to 9:14 a.m.",
      "116"= "9:50 a.m. to 9:54 a.m.",
      "128"= "10:50 a.m. to 10:54 a.m.",
      "133"= "11:15 a.m. to 11:19 a.m.",
      "136"= "11:30 a.m. to 11:34 a.m.",
      "147"= "12:25 p.m. to 12:29 p.m.",
      "154"= "1:00 p.m. to 1:04 p.m.",
      "155"= "1:05 p.m. to 1:09 p.m.",
      "161"= "1:35 p.m. to 1:39 p.m.",
      "162"= "1:40 p.m. to 1:44 p.m.",
      "167"= "2:05 p.m. to 2:09 p.m.",
      "175"= "2:45 p.m. to 2:49 p.m.",
      "177"= "2:55 p.m. to 2:59 p.m.",
      "186"= "3:40 p.m. to 3:44 p.m.",
      "190"= "4:00 p.m. to 4:04 p.m.",
      "191"= "4:05 p.m. to 4:09 p.m.",
      "193"= "4:15 p.m. to 4:19 p.m.",
      "200"= "4:50 p.m. to 4:54 p.m.",
      "201"= "4:55 p.m. to 4:59 p.m.",
      "226"= "7:00 p.m. to 7:04 p.m.",
      "232"= "7:30 p.m. to 7:34 p.m.",
      "236"= "7:50 p.m. to 7:54 p.m.",
      "237"= "7:55 p.m. to 7:59 p.m.",
      "238"= "8:00 p.m. to 8:04 p.m.",
      "240"= "8:10 p.m. to 8:14 p.m.",
      "242"= "8:20 p.m. to 8:24 p.m.",
      "245"= "8:35 p.m. to 8:39 p.m.",
      "250"= "9:00 p.m. to 9:04 p.m.",
      "275"= "11:05 p.m. to 11:09 p.m.",
      "283"= "11:45 p.m. to 11:49 p.m.",
      "285"= "11:55 p.m. to 11:59 p.m.",
      "012"= "1:05 a.m. to 1:09 a.m.",
      "024"= "2:10 a.m. to 2:14 a.m.",
      "026"= "2:20 a.m. to 2:24 a.m.",
      "027"= "2:25 a.m. to 2:29 a.m.",
      "030"= "2:40 a.m. to 2:44 a.m.",
      "032"= "2:50 a.m. to 2:54 a.m.",
      "040"= "3:30 a.m. to 3:34 a.m.",
      "045"= "3:55 a.m. to 3:59 a.m.",
      "047"= "4:05 a.m. to 4:09 a.m.",
      "063"= "5:25 a.m. to 5:29 a.m.",
      "066"= "5:40 a.m. to 5:44 a.m.",
      "086"= "7:20 a.m. to 7:24 a.m.",
      "096"= "8:10 a.m. to 8:14 a.m.",
      "099"= "8:25 a.m. to 8:29 a.m.",
      "102"= "8:40 a.m. to 8:44 a.m.",
      "109"= "9:15 a.m. to 9:19 a.m.",
      "110"= "9:20 a.m. to 9:24 a.m.",
      "112"= "9:30 a.m. to 9:34 a.m.",
      "113"= "9:35 a.m. to 9:39 a.m.",
      "115"= "9:45 a.m. to 9:49 a.m.",
      "120"= "10:10 a.m. to 10:14 a.m.",
      "127"= "10:45 a.m. to 10:49 a.m.",
      "130"= "11:00 a.m. to 11:04 a.m.",
      "131"= "11:05 a.m. to 11:09 a.m.",
      "145"= "12:15 p.m. to 12:19 p.m.",
      "159"= "1:25 p.m. to 1:29 p.m.",
      "168"= "2:10 p.m. to 2:14 p.m.",
      "176"= "2:50 p.m. to 2:54 p.m.",
      "188"= "3:50 p.m. to 3:54 p.m.",
      "195"= "4:25 p.m. to 4:29 p.m.",
      "213"= "5:55 p.m. to 5:59 p.m.",
      "229"= "7:15 p.m. to 7:19 p.m.",
      "231"= "7:25 p.m. to 7:29 p.m.",
      "0"= "NA"
  )
    
    # Creating list of all possible values of JWDP
    times_JWDP <- c(
     "014"= "4:10 a.m. to 4:19 a.m.",
      "015"= "4:20 a.m. to 4:29 a.m.",
      "017"= "4:40 a.m. to 4:49 a.m.",
      "022"= "5:15 a.m. to 5:19 a.m.",
      "035"= "6:20 a.m. to 6:24 a.m.",
      "046"= "7:15 a.m. to 7:19 a.m.",
      "065"= "8:50 a.m. to 8:54 a.m.",
      "068"= "9:05 a.m. to 9:09 a.m.",
      "076"= "9:45 a.m. to 9:49 a.m.",
      "079"= "10:00 a.m. to 10:09 a.m.",
      "083"= "10:40 a.m. to 10:49 a.m.",
      "085"= "11:00 a.m. to 11:09 a.m.",
      "086"= "11:10 a.m. to 11:19 a.m.",
      "103"= "2:00 p.m. to 2:09 p.m.",
      "105"= "2:20 p.m. to 2:29 p.m.",
      "118"= "4:30 p.m. to 4:39 p.m.",
      "127"= "6:00 p.m. to 6:09 p.m.",
      "130"= "6:30 p.m. to 6:39 p.m.",
      "131"= "6:40 p.m. to 6:49 p.m.",
      "139"= "9:20 p.m. to 9:29 p.m.",
      "141"= "9:40 p.m. to 9:49 p.m.",
      "149"= "11:00 p.m. to 11:29 p.m.",
      "057"= "8:10 a.m. to 8:14 a.m.",
      "059"= "8:20 a.m. to 8:24 a.m.",
      "063"= "8:40 a.m. to 8:44 a.m.",
      "066"= "8:55 a.m. to 8:59 a.m.",
      "073"= "9:30 a.m. to 9:34 a.m.",
      "078"= "9:55 a.m. to 9:59 a.m.",
      "100"= "1:30 p.m. to 1:39 p.m.",
      "101"= "1:40 p.m. to 1:49 p.m.",
      "104"= "2:10 p.m. to 2:19 p.m.",
      "107"= "2:40 p.m. to 2:49 p.m.",
      "111"= "3:20 p.m. to 3:29 p.m.",
      "116"= "4:10 p.m. to 4:19 p.m.",
      "128"= "6:10 p.m. to 6:19 p.m.",
      "150"= "11:30 p.m. to 11:59 p.m.",
      "010"= "3:30 a.m. to 3:39 a.m.",
      "011"= "3:40 a.m. to 3:49 a.m.",
      "019"= "5:00 a.m. to 5:04 a.m.",
      "028"= "5:45 a.m. to 5:49 a.m.",
      "044"= "7:05 a.m. to 7:09 a.m.",
      "045"= "7:10 a.m. to 7:14 a.m.",
      "047"= "7:20 a.m. to 7:24 a.m.",
      "049"= "7:30 a.m. to 7:34 a.m.",
      "053"= "7:50 a.m. to 7:54 a.m.",
      "055"= "8:00 a.m. to 8:04 a.m.",
      "056"= "8:05 a.m. to 8:09 a.m.",
      "084"= "10:50 a.m. to 10:59 a.m.",
      "090"= "11:50 a.m. to 11:59 a.m.",
      "092"= "12:10 p.m. to 12:19 p.m.",
      "110"= "3:10 p.m. to 3:19 p.m.",
      "112"= "3:30 p.m. to 3:39 p.m.",
      "120"= "4:50 p.m. to 4:59 p.m.",
      "132"= "6:50 p.m. to 6:59 p.m.",
      "133"= "7:00 p.m. to 7:29 p.m.",
      "134"= "7:30 p.m. to 7:59 p.m.",
      "009"= "3:20 a.m. to 3:29 a.m.",
      "023"= "5:20 a.m. to 5:24 a.m.",
      "031"= "6:00 a.m. to 6:04 a.m.",
      "038"= "6:35 a.m. to 6:39 a.m.",
      "040"= "6:45 a.m. to 6:49 a.m.",
      "050"= "7:35 a.m. to 7:39 a.m.",
      "060"= "8:25 a.m. to 8:29 a.m.",
      "062"= "8:35 a.m. to 8:39 a.m.",
      "064"= "8:45 a.m. to 8:49 a.m.",
      "067"= "9:00 a.m. to 9:04 a.m.",
      "069"= "9:10 a.m. to 9:14 a.m.",
      "082"= "10:30 a.m. to 10:39 a.m.",
      "095"= "12:40 p.m. to 12:49 p.m.",
      "096"= "12:50 p.m. to 12:59 p.m.",
      "097"= "1:00 p.m. to 1:09 p.m.",
      "119"= "4:40 p.m. to 4:49 p.m.",
      "121"= "5:00 p.m. to 5:09 p.m.",
      "135"= "8:00 p.m. to 8:29 p.m.",
      "003"= "1:00 a.m. to 1:29 a.m.",
      "033"= "6:10 a.m. to 6:14 a.m.",
      "036"= "6:25 a.m. to 6:29 a.m.",
      "041"= "6:50 a.m. to 6:54 a.m.",
      "061"= "8:30 a.m. to 8:34 a.m.",
      "081"= "10:20 a.m. to 10:29 a.m.",
      "093"= "12:20 p.m. to 12:29 p.m.",
      "098"= "1:10 p.m. to 1:19 p.m.",
      "102"= "1:50 p.m. to 1:59 p.m.",
      "109"= "3:00 p.m. to 3:09 p.m.",
      "115"= "4:00 p.m. to 4:09 p.m.",
      "126"= "5:50 p.m. to 5:59 p.m.",
      "143"= "10:00 p.m. to 10:09 p.m.",
      "145"= "10:20 p.m. to 10:29 p.m.",
      "001"= "12:00 a.m. to 12:29 a.m.",
      "006"= "2:30 a.m. to 2:59 a.m.",
      "012"= "3:50 a.m. to 3:59 a.m.",
      "013"= "4:00 a.m. to 4:09 a.m.",
      "016"= "4:30 a.m. to 4:39 a.m.",
      "025"= "5:30 a.m. to 5:34 a.m.",
      "026"= "5:35 a.m. to 5:39 a.m.",
      "030"= "5:55 a.m. to 5:59 a.m.",
      "077"= "9:50 a.m. to 9:54 a.m.",
      "087"= "11:20 a.m. to 11:29 a.m.",
      "088"= "11:30 a.m. to 11:39 a.m.",
      "094"= "12:30 p.m. to 12:39 p.m.",
      "106"= "2:30 p.m. to 2:39 p.m.",
      "108"= "2:50 p.m. to 2:59 p.m.",
      "122"= "5:10 p.m. to 5:19 p.m.",
      "123"= "5:20 p.m. to 5:29 p.m.",
      "124"= "5:30 p.m. to 5:39 p.m.",
      "144"= "10:10 p.m. to 10:19 p.m.",
      "002"= "12:30 a.m. to 12:59 a.m.",
      "004"= "1:30 a.m. to 1:59 a.m.",
      "005"= "2:00 a.m. to 2:29 a.m.",
      "007"= "3:00 a.m. to 3:09 a.m.",
      "020"= "5:05 a.m. to 5:09 a.m.",
      "021"= "5:10 a.m. to 5:14 a.m.",
      "024"= "5:25 a.m. to 5:29 a.m.",
      "027"= "5:40 a.m. to 5:44 a.m.",
      "034"= "6:15 a.m. to 6:19 a.m.",
      "039"= "6:40 a.m. to 6:44 a.m.",
      "042"= "6:55 a.m. to 6:59 a.m.",
      "043"= "7:00 a.m. to 7:04 a.m.",
      "048"= "7:25 a.m. to 7:29 a.m.",
      "051"= "7:40 a.m. to 7:44 a.m.",
      "058"= "8:15 a.m. to 8:19 a.m.",
      "072"= "9:25 a.m. to 9:29 a.m.",
      "074"= "9:35 a.m. to 9:39 a.m.",
      "075"= "9:40 a.m. to 9:44 a.m.",
      "091"= "12:00 p.m. to 12:09 p.m.",
      "113"= "3:40 p.m. to 3:49 p.m.",
      "117"= "4:20 p.m. to 4:29 p.m.",
      "125"= "5:40 p.m. to 5:49 p.m.",
      "129"= "6:20 p.m. to 6:29 p.m.",
      "136"= "8:30 p.m. to 8:59 p.m.",
      "137"= "9:00 p.m. to 9:09 p.m.",
      "140"= "9:30 p.m. to 9:39 p.m.",
      "008"= "3:10 a.m. to 3:19 a.m.",
      "018"= "4:50 a.m. to 4:59 a.m.",
      "029"= "5:50 a.m. to 5:54 a.m.",
      "032"= "6:05 a.m. to 6:09 a.m.",
      "037"= "6:30 a.m. to 6:34 a.m.",
      "052"= "7:45 a.m. to 7:49 a.m.",
      "054"= "7:55 a.m. to 7:59 a.m.",
      "070"= "9:15 a.m. to 9:19 a.m.",
      "071"= "9:20 a.m. to 9:24 a.m.",
      "080"= "10:10 a.m. to 10:19 a.m.",
      "089"= "11:40 a.m. to 11:49 a.m.",
      "099"= "1:20 p.m. to 1:29 p.m.",
      "114"= "3:50 p.m. to 3:59 p.m.",
      "138"= "9:10 p.m. to 9:19 p.m.",
      "142"= "9:50 p.m. to 9:59 p.m.",
      "146"= "10:30 p.m. to 10:39 p.m.",
      "147"= "10:40 p.m. to 10:49 p.m.",
      "148"= "10:50 p.m. to 10:59 p.m.",
       "0"= "NA"
  )
  
  
  # note sapply is discussed in week 8 (future material)
  JWAP_label <- sapply(times_JWAP, mid_time)
  JWDP_label <- sapply(times_JWDP, mid_time)
  
  # JWAP
  if ("JWAP" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
      mutate(JWAP = JWAP_label[JWAP])
  }
  
  # JWDP
  if ("JWDP" %in% colnames(Census_info)) {
    Census_info <- Census_info |>
      mutate(JWDP = JWDP_label[JWDP]) 
  }
  
  # From Data Manipulation step in instructions
  class(Census_info) <- c("census",class(Census_info))
  
  return(Census_info)
 
}
```

Now that its built lets **test** calling it with the URL we used above.

```{r}
URL_funct(test_URL)
```

Awesome, now lets build our function to...

## Query the Census API and Return a Table

The following function builds a URL for a single year of the API from user input and uses the previous function to make it a tibble. The code is divided into 2 main parts: logical qualifiers to align with project instructions and API limitations, and building a string to pass along to the generic URL function.

### Quoted URL String

Creating a function to call on specified variables from the Census API. Method: passing along variables to a paste statement based on the following specifications

-   Contains a year between 2010-2022

-   Return at least 2 numeric variables: PUMS person weight (PWGTP) and at least 1 of the following

    -   Age (AGEP), Gas Cost (GASP), Gross rent as a percentage of annual household income (GRPIP), Time of arrival at work (JWAP), Time of departure from work (JWDP), Travel time to work (JWMNP)

-   Return at least 1 categorical variable

    -   Gave birth to a child with the past 12 months (FER), Household Language (HHL), Broadband Internet service (HISPEED), Means of transportation to work (JWTRNS), School enrollment (SCH), Educational attainment (SCHL), Sex (SEX)

-   Optional argument to subset the data based on geography (All, Regions, Divisions, or States)

```{r}
query_api <- function(year=2022, vars = c("PWGTP"=NA, "AGEP"=NA, "SEX"=NA), geo_level = "state" , geo_code = 11){
  # year = year of census to call, default is 2022
  # vars = a vector of numerical and categorical indexes associated with their names default is PWGTP, AGEP, and SEX. The value NA means the variable is not going to be subsetted later.
  # geo_level = geographic level Region, Division or State. The default is state  
  # geo_code = geographic index code. The default is our group number, ours is 11 (Washington DC)
  
  # Logical Qualifiers
  
  # Making variable choices align with instructions
  
  #Empty for now
  geo_str<-""
  
  # User input to upper/lower case
  # i made geo lower case because thats how it is in url
  names(vars) <- toupper(names(vars))
  geo_level <- tolower(geo_level)
  
  # All variable options
  n_valid_vars <- c("PWGTP", "AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP")
  c_valid_vars <- c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX")
  valid_level <- c("region", "division", "state", "all")
  
  # Keep only those that appear in both the argument and valid variables based on the instruction
  n_var_names <- intersect(names(vars), n_valid_vars)
  c_var_names <- intersect(names(vars), c_valid_vars)
  geo_name <- intersect(geo_level, valid_level)
  
  # Creating tibble of valid n and c var limits based on variable information site
  var_limits <- data.frame(names = c(n_valid_vars[-which(names(vars) == "PWGTP")], c_valid_vars), 
                          lower_bound = c(0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1), 
                          upper_bound = c(99, 9999, 101, 285, 150, 200, 2, 5, 2, 12, 3, 24, 2))
  
  # This checks that year is numeric or not multiple years and between '10 and '22. It then checks that it is in the valid range and filters out the year 2020, where there is no data
  if (!is.numeric(year) | length(year) != 1){
    stop("Warning: Year must be a single numeric value")
  } else if(year > 2022 | year < 2010){
    stop("Warning: Year must be between 2010-2022")
  } else if(year == 2020){
    stop("Warning: The year 2020 has no data")
  }
  
  # filtering out variables from forum that if they are not in certain year
  if ("JWTRNS" %in% c_var_names & year < 2019){
    stop("Warning: JWTRNS was not recorded in the year provided")
  } 
  
  if ("HISPEED" %in% c_var_names & year < 2016){
    stop("Warning: HISPEED was not recorded in the year provided")
  }
  
  # Checks that at least 1 of numerical and categorical vars in the argument are valid
  # Double as the check that there is at least 1 categorical
  if (length(n_var_names) == 0 | length(c_var_names) == 0){
    stop("Warning: One or more variables are invalid or not enough variables as argument")
  } 
  
  # Giving note if one of the variable calls is invalid and subsetting to valid variables
  if ((length(n_var_names) + length(c_var_names)) < length(names(vars))){
      print("Note: One or more variables are invalid, returning only valid variables")
    vars <- vars[c(n_var_names, c_var_names)]
  }

  # PWGTP always included and at least one other numeric var
  if (length(n_var_names) < 2 | !("PWGTP" %in% n_var_names)){
    stop("Warning: PWGTP and at least 1 other valid numerical vector must be an argument")
  }
  
  # Assigning valid geo code based on selected region. 
  # If all is selected as geo_level, the variables get turned into normal columns. Hence the change from lower to upper case and state becoming ST.
  if (geo_name == "region"){
    valid_code <- c(1:4)
  } else if (geo_name == "division"){
      valid_code <- c(1:9)
  } else if (geo_name == "state"){
      valid_code <- c(1:56)[-c(3, 7, 14, 43, 52)] 
  } else{
    geo_name <- c("REGION", "DIVISION", "ST") 
    geo_code = "*"
  }
  
  # Making sure valid geo_code was given
  if (!(geo_code == "*" || geo_code == round(geo_code))){
    stop('Warning: geo_code must be an integer or "*"') 
  }
  
  # Assigning valid indexes for variables
  #Cannot be indexed: PWGTP
  for (i in 1:length(vars[-which(names(vars) == "PWGTP")])){
    if (!is.na(vars[i])){
      
      # Making sure given subset is an integer
      if (vars[i] != round(vars[i])){
        stop("Given subset must be an integer")
      }
      
      # Checking if given subset is within the bounds of the subset
      if (var_limits$lower_bound[which(var_limits$names == names(vars[i]))] > vars[i] | var_limits$upper_bound[which(var_limits$names == names(vars[i]))] < vars[i]){
        print(paste("Invalid Variable Subsetting. Returning all values of variable", names(vars[i])))
        vars[i] = NA
      } else if ((names(vars[i]) %in% n_var_names) & !(names(vars[i]) %in% c("JWAP", "JWDP"))){
        # Since these variables are given as ranges on the API site, there is no way to know if a specific value exists 
          print("Note: Numerical variable subsetted. While within the given range, Specific number may not be in the data")
      }
    }
  }
  
  # Fill in geo_str 
  
  if(length(geo_name) > 1){ 
    geo_str <- paste0(geo_name, collapse=,)
  } else if (geo_level %in% valid_level && ((geo_code %in% valid_code) | geo_code == "*")){
      geo_str<-paste0("&for=", geo_level, ":" ,geo_code)
  } else if (!(geo_level %in% valid_geo & geo_level != "all")){
      stop("Warning: Provided geography level is not valid")
  } else if (!(geo_code %in% valid_code)){
      stop("Warning: Provided geography code is not valid for your geography level")
  }

  
 # Creating master URL. The string is constructed differently based on whether or not there are any variables indexed or if the given geo_level was all (length(geo_name) > 1). Therefore, the api is built within the if then else statme
 if(!all(is.na(vars))){
   if(length(geo_name) > 1){
     api_url <- paste0("https://api.census.gov/data/", year, "/acs/acs1/pums?get=", 
                      paste(names(vars)[is.na(vars)], collapse=","), geo_str, "&",
                      paste0(names(vars)[!is.na(vars)], "=", vars[!is.na(vars)], collapse="&"))
   } else{
     api_url <- paste0("https://api.census.gov/data/", year, "/acs/acs1/pums?get=", 
                      paste(names(vars)[is.na(vars)], collapse=","), "&",
                      paste0(names(vars)[!is.na(vars)], "=", vars[!is.na(vars)], collapse="&"), geo_str)
   }
 } else{
    api_url <- paste0("https://api.census.gov/data/", year, "/acs/acs1/pums?get=", 
                      paste(names(vars)[is.na(vars)], collapse=","), geo_str)
 }
    
  return(URL_funct(api_url))

  
}
```

We want to **test** that our function to query and API worked!

```{r}
Census_tibble <- query_api(vars = c(PWGTP = NA, GASP=3, SEX = NA))
# does our function address 001 vs 1 vs 01 for jwdp?
# I just tested it in a URL and 001, 1, and 01 all return the same thing.

Census_tibble
```

## Creating Table that Spans Multiple Years

Last Data processing function. Specifies multiple years of survey data while keeping the rest of the variables constatnt

```{r}
build_multi_year_tbl <- function(years = c(2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2021, 2022), vars = c("PWGTP"=NA, "AGEP"=NA, "SEX"=NA), geo_level = "state" , geo_code = 11){
  
  if (any(years > 2022) | any(years < 2010) | any(years == 2020)){
    stop("Warning: Year must be between 2010-2022 and not 2020")
  }
  
  if ("JWTRNS" %in% names(vars) & any(years < 2019)){
    stop("Warning: JWTRNS only recorded in years greater than 2019")
  } 
  
  if ("HISPEED" %in% names(vars) & any(years < 2016)){
    stop("Warning: HISPEED was not recorded in the year provided")
  }
  
  multi_year_tbl = tibble()
  for (i in 1:length(years)){
    temp <- query_api(years[i], vars, geo_level, geo_code) |>
        mutate(
          year = years[i],
          .before = 1
        )
    multi_year_tbl <- bind_rows(multi_year_tbl, temp)
  }
  
  return(multi_year_tbl)
  
}
```

We want to **test** that our function to make a table with multiple years worked

```{r}
yrs = c(2012, 2013, 2021)
multi_yr_tbl <- build_multi_year_tbl(years = yrs)
multi_yr_tbl
```

# Manipulation

## Generic function for summarizing.

We went back to the generalized function (URL_funct) to build a table from an API URL to input the code to add a class to the census data for summarizing purposes. The code instructions on our tester table would look like

> class(Census_tibble) \<- c("census",class(Census_tibble))

The summarizing function will produce the means and standard deviations for specified numeric variables and the counts for specified categorical variables. The arguments would be the tibble produced from URL_funct, and the numeric and categorical variables to summarize. The numeric variables are weighted based on the peron weight vector, PWGTP.

```{r}
# summarizing function
summarize_census <- function(tibble, num_vars=NULL, cat_vars=NULL){
  # tibble we are using
  # num_vars are our numeric variables we want to summarize
  # cat_vars are our categorical variables we want to summarize
  # we did NULL default so we can use if logic later to return all
  
  # empty list for later
  results <- list()
  
  weight <- as.numeric(tibble$PWGTP)
  
  #numeric 
  
  # return all numeric names except PWGTP
  all_num <- tibble |>
    select(where(is.numeric), -PWGTP) |>
    names()
  
  # Keep only those that appear in both
  num_vars <- intersect(num_vars, all_num)
  
  # give us all numeric variables if none given
  if (is.null(num_vars)){
    num_vars <- all_num
  }
  
  # loop to go through this vector and compute mean and standard deviation
  # note: Given outline code for this. Replace x^2 with x*x
  for (i in num_vars){
    x <- tibble[[i]]
    x_mean <- sum(x*weight)/sum(weight)
    x_sd <- sqrt(sum(x*x*weight)/sum(weight)-(x_mean*x_mean))
    results[[i]] <- list(mean = x_mean, sd = x_sd)
  }
  
  # categorical
  
  # return all categorical names
  all_cat <- tibble |>
  select(where(is.character), where(is.factor)) |>
  names()
  
  # Keep only those that appear in both
  cat_vars <- intersect(cat_vars, all_cat)
  
  # give us all categorical variables if none given
  if (is.null(cat_vars)){
    cat_vars <- all_cat
  } 
  
  # loop to go through this vector and compute counts
  # tapply is base R read through the documentation on it in the help tab
  for (i in cat_vars){
    counts <- tapply(weight, tibble[[i]],sum)  
    results[[i]] <- as.list(counts)
  }
  
  return(results)
}


```

We are now going to **test** our summary function! We used the test tibble from when we tested our API query!

```{r}
#test for this function
summarize_census(Census_tibble, "GASP", "SEX")
```

## Plotting Function

Next we will create our plot function. We are requiring to user to specify one categorical and one numeric variable for plotting purposes.

```{r}
plot_Census <- function(tibble , num_var , cat_var){
  
  # valid num
  all_num <- tibble |>
  select(where(is.numeric), -PWGTP) |>
  names()
  
  # valid cat
  all_cat <- tibble |>
  select(where(is.character), where(is.factor)) |>
  names()
  
  # to uppercase
  names(num_var) <- toupper(names(num_var))
  names(cat_var) <- toupper(names(cat_var))
  
  # only one cat or num variable
  if (length(cat_var) != 1 | length(num_var) != 1) {
    stop("Warning: Please specify one categorical and one numeric variable.")
  } else if (!(cat_var %in% all_cat) || !(num_var %in% all_num)){
    stop("Warning: Invalid categorical or numeric variable specified")
  }
  
  # this code was given
  ggplot(tibble,
    aes(x = get(cat_var), y = get(num_var), weight = as.numeric(PWGTP))) + geom_boxplot() + 
    xlab(cat_var) + ylab(num_var) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
}

```

Now we will **test** our function for plots works! Again we will use test tibble from testing our API query.

```{r}
plot_Census(Census_tibble, "GASP", "SEX")
```

This example was not very informative because the value of GASP is 3 for the specified qualifiers. For the following code chunk we will use our functions to build a plot based on Household Language and Gross rent as a percentage of household income

```{r}
plot_Census(query_api(year = 2022, vars = c(PWGTP = NA, GRPIP = NA, HHL = NA)), "GRPIP", "HHL")
```


# Investigation

The plot of household language (HHL) against gross rent as a percentage of yearly household income (GRPIP) yielded an interesting result. It appears that in Washington DC (state 11) in the year 2022, approximately half of the households who speak English only or a non-Spanish Indo-European language do not have a value associated with rent. Specifically, "N/A (GQ/vacant/owned or being bought/occupied without rent payment/no household income)"

Let us see what this plot looks like without the NA values. So what happens if we only look at the people paying rent. 
```{r}
full_tbl2022 <- query_api(year = 2022, vars = c(PWGTP = NA, GRPIP = NA, HHL = NA))
invest_tbl2022 <- (query_api(year = 2022, vars = c(PWGTP = NA, GRPIP = NA, HHL = NA))) |>
  filter(GRPIP > 0)


plot_Census(invest_tbl2022, "GRPIP", "HHL")
                
```

Now the variable medians are "flipped". Of the people who pay rent, households who speak English only or a non-Spanish Indo-European language tend to pay more.

Does this hold true for the year 2021?
```{r}
full_tbl2021 <- query_api(year = 2021, vars = c(PWGTP = NA, GRPIP = NA, HHL = NA))
invest_tbl2021 <- full_tbl2021 |>
  filter(GRPIP > 0)

plot_Census(full_tbl2021, "GRPIP", "HHL")
plot_Census(invest_tbl2021, "GRPIP", "HHL")
```
This data is completely different that for the following year. Is it because of COVID-19? Let us investigate once more with the year 2018.
```{r}
full_tbl2018 <- query_api(year = 2018, vars = c(PWGTP = NA, GRPIP = NA, HHL = NA))
invest_tbl2018 <- full_tbl2018 |>
  filter(GRPIP > 0)

plot_Census(full_tbl2018, "GRPIP", "HHL")
plot_Census(invest_tbl2018, "GRPIP", "HHL")
```
These graphs look much more like those from 2022, so it seems like COVID-19 may have played a role in the number of people not paying rent in Washington DC. However, the inner-quartile ranges of the rent percentage is much smaller.

Based on these findings, future research can focus on the following. What percentage of the people who pay zero rent own their house versus just do not pay rent (e.g. someone living with their parents)? What is it about English only households that causes them to have at least half of the population not paying rent? Is there a confounding factor between household language and the percentage of annual income set aside for rent? Is the inner-quartile range for GRPIP growing because of decreased/stagnated annual income, increased rent amount, or both?
